<div id="content">
 <p>
The following programs mostly target power-users and programmers.
</p>

 <p>
Recurring characteristics:
</p>

 <ul class="org-ul"> <li>free software</li>
 <li>lightweight</li>
 <li>fast</li>
 <li>featureful (I want the program to empower me, not to restrict me)</li>
 <li>versionable configuration (plain text, non-XML)</li>
 <li>keyboard-driven</li>
 <li>text-oriented interface</li>
</ul> <p>
Or more simply put, an Emacs package…
</p>

 <p>
I try to  <a href="../emacs-eshell/index.html">avoid  <i>curses</i>-based programs</a>.
</p>

 <p>
Other application listings:
</p>

 <ul class="org-ul"> <li> <a href="https://wiki.archlinux.org/index.php/List_of_applications">https://wiki.archlinux.org/index.php/List_of_applications</a></li>

 <li> <a href="https://www.gnu.org/manual/blurbs.html">https://www.gnu.org/manual/blurbs.html</a>: The GNU software collection contains
some not-so-famous gems.  I think it deserves more fame.</li>
</ul> <p>
My personal listing:
</p>

 <ul class="org-ul"> <li> <b>3D graphics:</b> Blender</li>

 <li> <b>Archivers:</b> atool, bzip2, cabextract, cdrtools, cpio, gzip, lha, lrzip, lz4,
lzip, lzop, p7zip, plzip, unace, unarj, unrar, unshield, unzip, upx, xz

 <ul class="org-ul"> <li> <p>
 <code>atool</code> is a wrapper around many tools to unify compression and extraction
from command-line.
</p>

 <p>
Tip: add  <code>use_plzip 1</code> to  <code>~/.atoolrc</code> to automatically create
high-compression .tar.lz archives using multiple processors to divided
compression and compression time by (roughly) the number of available cores.
</p></li>

 <li> <code>cdrtools</code> can process ISO files.</li>

 <li> <p>
 <code>xz</code> and  <code>lzip</code> offer a good compression ratio together with great
decompression performance.  Compression is quite demanding.   <code>bzip2</code> has
little to offer compared to  <code>xz</code> or  <code>lzip</code>.   <code>p7zip</code> has the features of
 <code>tar</code>,  <code>xz</code> and  <code>ccrypt</code> in one program.
</p>

 <p>
 <code>lzip</code> is similar to  <code>xz</code> but is keeps memory consumption under control and
offers parallel compression and decompression with  <code>plzip</code>.
</p></li>

 <li> <code>lrzip</code> is similar to  <code>plzip</code>: it parallelizes compression using LZMA by
default, but unlike  <code>plzip</code> it supports other algorithms such as  <code>lzo</code>
(ultra fast) and  <code>zpaq</code> (extreme compression).</li>

 <li> <code>upx</code> can compress executables.</li>

 <li>The rest is for decompression.</li>
</ul></li>

 <li> <b>Assembly:</b> NASM, Yasm</li>

 <li> <b>Audio editors:</b> Audacity</li>

 <li> <b>Binary file tools:</b> chrpath, DHEX, Emacs (nhexl-mode), ltrace, nm, od, strace</li>

 <li> <b>Bindings:</b> xbindkeys, xcape, xdotool</li>

 <li> <b>Calculation:</b> bc, calc, Emacs (calc, Lisp), Maxima, PARI/GP, Octave

 <ul class="org-ul"> <li> <code>bc</code> and  <code>calc</code> are simple arbitrary-precision calculators.   <code>bc</code> is lighter
but  <code>calc</code> has somewhat more features.  Both can be used in limited
environments or in shell scripts.  Emacs’  <code>M-x calc</code> is more complete and
more convenient for interactive use.  Emacs also has  <code>M-x ielm</code>.</li>

 <li> <code>PARI/GP</code> is an extremely fast and advanced algebra system for number
theory.  Great for prime numbers and such.</li>

 <li> <code>Octave</code> will serve as a Unix-designed Matlab.</li>
</ul></li>

 <li> <b>Camera capture:</b> Guvcview, q4vl2</li>

 <li> <p>
 <b>Clipboard tools:</b> xsel
</p>

 <p>
Using  <a href="../emacs-everywhere/index.html">Emacs everywhere</a>,  <code>xsel</code> is barely useful.  I only use it to yank the
filename of pictures from  <code>sxiv</code>.
</p></li>

 <li> <p>
 <b>Contacts:</b> Emacs (org-contacts)
</p>

 <p>
I used to use  <code>Abook</code>, a stand-alone  <i>curses</i> contact manager.  Contacts are
stored in plain text and as such they are versionable, but the automatic
numbering makes up for huge diffs.  The  <i>curses</i> interface is not very
powerful (limited search capabilities, limited edition).
</p>

 <p>
 <code>Org-contacts</code> is much more powerful than  <code>Abook</code>: free form, arbitrary
fields, contacts can be fuzzy-searched or retrieved from anywhere within
Emacs.
</p>

 <p>
Versioning your contacts is a great way to centralize them, instead of
spreading them across your mail agent contacts, CSV files, etc.  Plain text
contacts also means it is easy to write a converter from a CSV file
(e.g. using Emacs Lisp or  <code>AWK</code>).
</p></li>

 <li> <b>Cryptocurrencies:</b> electrum</li>

 <li> <b>Cryptography:</b> ccrypt, encfs, GnuPG, pass, Pwgen

 <ul class="org-ul"> <li> <code>GnuPG</code> is essential at many levels, from communication to data encryption.
Asymmetric encryption ensures that sensitive data stored on an untrusted
platform (i.e. online) cannot be compromised remotely by reversing a bad
password.</li>

 <li> <code>ccrypt</code> is good at encrypting single files symmetrically, e.g. for users
without a PGP key.</li>

 <li> <code>encfs</code> can encrypt folders and mount them as an encrypted file
system.  Files can be browsed transparently without being ever written in
clear to the disk.  It uses a  <i>fuse</i> backend which makes it portable across
systems at the expense of speed.</li>

 <li> <a href="https://www.passwordstore.org/"> <code>pass</code></a> is one of the few password managers that can be used to safely store
and synchronize passwords online.  It uses asymmetric encryption (through
 <code>GnuPG</code>).  Git is used to synchronize the password store.  I recommend using
Emacs’  <code>helm-pass</code> to fuzzy-search the passwords on input.</li>
</ul></li>

 <li> <b>Dictionaries:</b> aspell</li>

 <li> <b>Diff tools:</b> Emacs (ediff, ztree), diffoscope</li>

 <li> <b>Disk utilities:</b> Emacs (disk-usage), gparted, parted, rmlint, shred, trashed, tree, wipe

 <ul class="org-ul"> <li>Emacs’  <a href="https://gitlab.com/ambrevar/emacs-disk-usage">disk-usage</a> is a good alternative to  <code>ncdu</code>: it’s a very fast and
convenient disk usage analyzer.</li>

 <li>Emacs’  <a href="https://github.com/shingo256/trashed/">trashed</a> is an interface implementing FreeDesktop.org’s Trash
specification.  It is much more convenient than  <code>trash-cli</code>, notably to mark
and perform actions on select trashed files.  Emacs also has the
 <code>delete-by-moving-to-trash</code> variable.</li>

 <li> <code>wipe</code> can delete folders securely while  <code>shred</code> can only process files.</li>
</ul></li>

 <li> <p>
 <b>Document processing:</b> Emacs (Org-mode), lilypond, pdf2svg, Texinfo, TeX Live
</p>

 <p>
Consider using Org-mode over other markup formats like Markdown.  See
 <a href="http://karl-voit.at/2017/09/23/orgmode-as-markup-only">http://karl-voit.at/2017/09/23/orgmode-as-markup-only</a>.
</p>

 <p>
Prefer Texinfo over Man pages which are very limited.  Most  <i>man</i> readers
don’t support cross-references, fuzzy search or section browsing.  Both Emacs’
 <code>M-x man</code> and  <code>M-x woman</code> support those features however.  Texinfo manuals
automatically generate an index which is extremelly useful for browsing.
</p>

 <p>
TeX-based processors offer the best typographic rendering while based on what
is possibly the worst programming language.  Org-mode has good export support for
TeX / LaTeX.
</p></li>

 <li> <p>
 <b>Document readers and tools:</b> antiword, apvlv, catdvi, catdoc, docx2txt,
Emacs (pdf-tools), evince, ghostscript, odt2txt, mcomix, poppler, pstotext,
unrtf, wv, xchm, zathura
</p>

 <ul class="org-ul"> <li> <code>apvlv</code>,  <code>pdf-tools</code> and  <code>zathura</code> are light and keyboard-driven.   <code>zathura</code>
supports PostScript  <code>.ps</code> files and SyncTeX.   <code>apvlv</code> supports UMD, HTML and  <code>.txt</code>
files.   <code>pdf-tools</code> supports SyncTeX and has good text search and selection
facilities, it enables many Emacs features (Helm, Ivy).</li>

 <li> <code>Evince</code> is far too heavy but can fill PDF forms.  (Yet another ill-conceived
PDF feature…)</li>

 <li> <code>Poppler</code> has numerous PDF converters (e.g.  <i>pdftotext</i>).</li>

 <li> <code>ghostscript</code> can convert PDF to and from PS.</li>
</ul> <p>
Most of these programs can be used for previewing document formats in text
form.
</p></li>

 <li> <p>
 <b>E-mail clients:</b> Emacs (mu4e, notmuch)
</p>

 <p>
I used to use  <code>Mutt</code>: it’s extremely hard to configure for a very limited
result.  It does not support viewing e-mails and composing at the same time;
you can’t really copy text from the pager; multiple-account support is rather
tedious to configure.
</p>

 <p>
 <code>mu4e</code> is moderately easy to configure, extremely extensible with Emacs Lisp
and does not suffer from the limitations of Mutt.  You can fuzzy-search
contacts, e-mails, preview HTML, display embedded pictures and much more.
</p>

 <p>
 <code>notmuch</code> has supports tagging and tree display of threads:
 <a href="https://notmuchmail.org/screenshots/#index4h3">https://notmuchmail.org/screenshots/#index4h3</a>
</p></li>

 <li> <b>File browsers:</b> Emacs (dired, Helm Find-Files), ranger

 <ul class="org-ul"> <li>I used to use  <code>ranger</code>, but being  <i>curses</i>-based, it can only be that
useful.  The column display is nice though.  It can preview all sorts of
file but graphics display is obviously limited.  Emacs-based browsers are
much better at this.  It can run an arbitrary command on any file selection
and it remembers the selection in every folder.  It can run various powerful
commands conveniently, such as recursive hardlink creation or
batch-renaming.</li>

 <li>Emacs’  <code>Helm Find-Files</code> makes for a revolutionary file browser: typing
anything will fuzzy-filter the current directory, or even subdirectories.
The filtered results can be browsed with special keys: you can select files
from different directories and apply arbitrary actions to them.  It has a
binding to switch to  <code>Eshell</code> from the currently-browsed folder.  It’s
possible to batch-rename selected files from multiple folders using
 <code>Wdired</code>.</li>
</ul></li>

 <li> <b>File synchronization:</b> hsync, rsync

 <ul class="org-ul"> <li>Read the documentation carefully.   <code>rsync</code> has a lot of useful options, like
 <code>--append-verify</code>,  <code>--progress</code> and  <code>--size-only</code>.</li>

 <li> <a href="../hsync/index.html"> <code>hsync</code></a> is useful to detect renamings and can be called before  <code>rsync</code> to
speed up the process.</li>
</ul></li>

 <li> <p>
 <b>Finders:</b> Emacs (Helm, Ivy)
</p>

 <p>
I used to really like  <code>fzf</code> and search programs like  <code>agrep</code> (from the  <code>tre</code>
package) or  <code>ag</code> (The Silver Searcher).  If you live in Emacs, those are
completely superseded by Helm or Ivy.
</p>

 <p>
Emacs interactive completion can effectively be used everywhere: for
structured documents, code completion, file search, command history, folder
history and more.
</p></li>

 <li> <p>
 <b>FTP clients:</b> curlftpfs, Emacs (TRAMP), NcFTP
</p>

 <p>
Emacs’ TRAMP allows you to work on remote files (move, delete, download) and
edit them transparently: first they are automatically downloaded, then all
edits are done locally within Emacs, and last the file is uploaded upon
saving.
</p></li>

 <li> <b>FTP servers:</b> vsftpd</li>

 <li> <p>
 <b>Gaming emulators:</b> DGen, DOSBox, Gens/GS, Lutris, Mupen64Plus, PCSX-Reloaded,
MAME, Wine
</p>

 <p>
Lutris attempts to provide a one-click install & play interface.  It’s
especially useful for games that are tricky to configure right.
</p></li>

 <li> <b>Gaming tools:</b> DriConf, TiMidity++, xosd

 <ul class="org-ul"> <li> <code>osd_cat</code> from  <code>xosd</code> can display text on screen, such as FPS or network
traffic.</li>

 <li> <code>TiMidity++</code> is useful for old games using midi music.</li>
</ul></li>

 <li> <b>Job scheduling:</b> mcron

 <ul class="org-ul"> <li> <code>mcron</code> is a rewrite of the venerable  <code>cron</code> in Scheme (Guile).  Jobs can be
declared in Scheme, which allows for programming jobs.</li>
</ul></li>

 <li> <p>
 <b>Local file sharing:</b> woof, python, rsync
</p>

 <p>
FTP is sometimes blocked by routeurs and it does not offer many advantages for
casualy file sharing.  HTTP is more accessible for people running poor
systems, while Rsync is more powerful (e.g. partial transfers).
</p>

 <ul class="org-ul"> <li> <code>woof</code> is very convenient to share single files over HTTP with anyone.  It
also support an upload form so that other people can send you files.   <code>woof</code>
does not support sharing of directories (without taring them first, that is to
say).</li>

 <li> <p>
 <code>python</code> also comes with a simple HTTP server:
</p>
 <div class="org-src-container">
 <pre class="src src-sh">python3 -m http.server 8080
</pre>
</div>
 <p>
or in a Guix container for extra security:
</p>
 <div class="org-src-container">
 <pre class="src src-sh">guix environment -C -N --ad-hoc python -- python3 -m http.server 8080
</pre>
</div>
 <p>
The python HTTP server automatically shares the entire current directory.
</p>

 <p>
While the client can use any browser to fetch the files one by one,  <code>wget</code> is
more convenient to fetch everything at once while enabling compression:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">wget -R 'index.html*' -r --content-disposition --compression=gzip "$@"
</pre>
</div>

 <p>
In the above we exclude ’index.html’ otherwise they would be created for
every directory.
</p></li>

 <li> <p>
Finally, if you need more fine-tuned data transfer options such as
only transfering the portion of the files that changed) and
preserving permissions, consider using  <code>rsync</code>.
A server can be started without privilege using the  <code>--daemon</code> option and
using a port in the allowed range (typically 1024).
</p>

 <p>
See my  <a href="https://gitlab.com/ambrevar/dotfiles/-/blob/4221e45956ea848408ba671b80bb8767c21a54be/.local/bin/rshare">rshare</a> script which acts as a convenience wrapper:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">rshare /my/folder
</pre>
</div>

 <p>
The client can then run:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">rsync -azzPiv rsync://HOST:PORT/files /path/to/destination
</pre>
</div>

 <p>
 <code>-P</code> enables partial transfers and shows progress.   <code>-zz</code> enables
compression.   <code>-i</code> shows the changes that are applied (e.g. a change in
permissions).
</p></li>
</ul></li>

 <li> <b>Music:</b> Beets, clyrics, cmus, Demlo, Emacs (EMMS), mps-youtube, youtube-viewer

 <ul class="org-ul"> <li> <code>clyrics</code> can display the lyrics of the song currently playing in  <code>cmus</code>.</li>

 <li>The  <code>cmus</code> music player is extremely fast at updating its database.  The
 <i>curses</i>-based UI is a bit limitating though.</li>

 <li>Emacs’ EMMS is similar to cmus with the bonus that it is extensible, it can
fetch lyrics, it can resume state upon restart and it can display album covers
within the music library tree.</li>

 <li> <code>mps-youtube</code> can build albums from Youtube links automatically and save the
resulting playlist locally.  Since it’s terminal-based it cannot display
thumbnails.</li>

 <li> <code>youtube-viewer</code> is similar to  <code>mps-youtube</code> but its graphical interface can
display thumbnails which is very convenient to help the user find a video.
I find it less convenient than  <code>mps-youtube</code> to build playlists though.</li>
</ul></li>

 <li> <b>Network monitors:</b> Aircrack-ng, ngrep, nmap, speedtest-cli, Tcpdump, Wireshark</li>

 <li> <b>News readers:</b> Emacs (elfeed)

 <ul class="org-ul"> <li>Elfeed is better at rendering HTML feeds than  <code>newsbeuter</code>, it supports
image display, it can fuzzy-search everything.</li>
</ul></li>

 <li> <b>Package management:</b> Emacs (helm-system-packages), Guix, Stow

 <ul class="org-ul"> <li> <code>Guix</code> can be installed on any system.  It allows for rollbacks, unprivileged
package management, etc.  It’s extensible in Scheme (Guile).</li>

 <li> <code>Helm System Packages</code> is a universal interface to your package manager.  It
lets you fuzzy-search and execute complex actions over arbitrary selections
of packages.</li>

 <li>GNU  <code>Stow</code> is convenient to install packages locally (without using a
package manager).  I also find it convenient for dotfiles management.</li>
</ul></li>

 <li> <b>Picture batch processors:</b> dcraw, Emacs (gif-screencast), gifsicle,
GraphicsMagick, ImageMagick, jpegtran (from libjpeg-turbo), optipng

 <ul class="org-ul"> <li> <code>dcraw</code> can convert many camera raw formats.</li>

 <li> <code>GraphicsMagick</code> and  <code>ImageMagick</code> are very similar in features and they may
be complementary regarding performance.</li>
</ul></li>

 <li> <b>Picture editors (Raster graphics):</b> darktable, GIMP, Hugin, Metapixel, RawTherapee</li>

 <li> <b>Picture information:</b> perl-image-exiftool</li>

 <li> <b>Picture viewers:</b> feh, sxiv

 <ul class="org-ul"> <li> <code>feh</code> can set the wallpaper.   <code>sxiv</code> is very fast at loading and displaying big
pictures.  It supports GIF animations unlike  <code>feh</code>.</li>
</ul></li>

 <li> <b>Power usage monitors:</b> powertop</li>

 <li> <b>Programming:</b> cloc</li>

 <li> <b>Programming in C:</b> cppcheck, GDB, mcpp, musl, Splint, TCC, Valgrind,
Uncrustify

 <ul class="org-ul"> <li> <code>cppcheck</code> and  <code>Splint</code> are static analyzers with overlapping features.</li>

 <li> <code>Uncrustify</code> is much better engineered than  <code>GNU Indent</code> and  <code>Astyle</code>.  See
the  <a href="../indentation/index.html">Indentation rationale</a>.</li>
</ul></li>

 <li> <b>Screen capture:</b> scrot</li>

 <li> <b>Screen control:</b> light, xbacklight

 <ul class="org-ul"> <li> <code>light</code> works without X as opposed to  <code>xbacklight</code>.</li>
</ul></li>

 <li> <b>Session locks:</b> slock, vlock, xlockmore, xss-lock

 <ul class="org-ul"> <li> <code>slock</code> is as simple as it gets but does not support PAM sessions unlike
 <code>xlockmore</code>.</li>

 <li> <code>vlock</code> is for TTY sessions.  It is part of the  <code>kbd</code> project.</li>

 <li> <code>xss-lock</code> auto-locks the screen on standby or when the laptop lid is closed.</li>
</ul></li>

 <li> <b>Shell:</b> DASH, dtach, Emacs (Eshell), fish, shellcheck

 <ul class="org-ul"> <li> <code>DASH</code> is a light, fast and POSIX compliant shell.  It is quite limited for
interactive use but ideal for testing the POSIX-ness of scripts.</li>

 <li> <code>dtach</code> detaches the command passed as argument, allowing it to run in the
background even after the parent program has been killed.  The backgrounded
program can be re-attached at any moment to another shell.   <code>dtach</code> also
works with Eshell.</li>

 <li> <p>
 <code>fish</code> departs from the POSIX-derived shells.   <code>Bash</code> suffers from the
design issues of the venerable Bourne shell (e.g. word-splitting).   <code>Zsh</code>
has tried to unite all shell languages under one banner, thus becoming
complicated beyond reason to the point that the simplest configuration can
be an Odyssey on its own.  Like  <code>rc</code>,  <code>fish</code> uses a clear syntax.  It also has
a straightforward API, which makes it very straighforward to customize and
extend.  Last but not least, its interactive features are efficient and to
the point.
</p>

 <p>
The lack of POSIX-ness is no problem in practice:
</p>

 <ul class="org-ul"> <li>Any POSIX shell script will be executed by the interpreter pointed by the
shebang.</li>

 <li>Initialization files such as  <code>.profile</code> can still be set up by  <code>sh</code> at the
beginning of the session: use  <code>sh</code> as your login shell and  <code>exec fish</code> at
the end.</li>
</ul></li>

 <li> <p>
Farther down the road of non-POSIX shells, Eshell lies even further: it uses
Emacs Lisp as a language which is arguably much more powerful than  <code>fish</code>.
See  <a href="../emacs-eshell/index.html">my article on Eshell</a> for more good reasons why you should use it.
</p>

 <p>
Eshell has a very powerful completion framework,  <code>pcomplete</code>.  As of 2017
the limited popularity of Eshell result in limited support for completion.
That being said, it is possible to configure Eshell so that  <a href="https://gitlab.com/ambrevar/emacs-fish-completion">it falls back on
the completion of  <code>fish</code></a>, which then makes for a very extensive completion
support.
</p></li>

 <li> <code>shellcheck</code> is a static-analyzer for shell scripts.</li>
</ul></li>

 <li> <b>Spreadsheet:</b> Emacs (Org-mode)

 <ul class="org-ul"> <li>This  <code>Emacs</code> mode lets you write plain text tables (track them with  <code>git</code>!)
and apply arbitrary functions to cells.  These functions are either
pre-defined or self-written in Lisp (with ubiquitous support for  <code>M-x calc</code>
and its arbitrary precision arithmetic).  From there you can use every Elisp
feature, and if that would not be enough (e.g. too slow) you can call
external programs to perform the task, say, your favourite scripting
language.  This makes the tables infinitely programmable.</li>
</ul></li>

 <li> <b>System information:</b> inxi</li>

 <li> <b>System monitors:</b> Emacs (proced, helm-top), htop, iftop, Iotop, lsof,
NetHogs, progress, PSmisc

 <ul class="org-ul"> <li> <p>
 <a href="https://github.com/Xfennec/progress">progress</a> is very useful to follow the progress of multiple file operations
from multiple programs at once.
</p>

 <p>
I like to add support for Emacs file operations with
</p>

 <pre class="example">
export PROGRESS_ARGS="-a emacs"
</pre>

 <p>
On Guix, since “emacs” is a shell wrapper, it would be:
</p>

 <pre class="example">
export PROGRESS_ARGS="-a .emacs-$(emacs -Q --batch --eval '(message emacs-version)' 2>&1)-real"
</pre></li>
</ul></li>

 <li> <b>Task management:</b> Emacs (Org-mode)

 <ul class="org-ul"> <li> <p>
Org-mode all the way.  It can be used as TODO manager, calendar, for
document processing, documentation, literate programming, etc.
</p>

 <p>
I briefly tried  <code>Taskwarrior</code>, which file format is plain text but hard to
read.  The editing is far less convenient than with a proper text editor.
This is where the power of using an editor as a user interface really
shines.  Org-mode is not an Emacs exclusivity, some other editors support
it.
</p></li>
</ul></li>

 <li> <p>
 <b>Text editors:</b> Emacs
</p>

 <p>
 <a href="https://www.youtube.com/watch?v=JWD1Fpdd4Pc">Yes, you should use Emacs</a>.
</p></li>

 <li> <p>
 <b>Text processing:</b> Emacs Lisp, recutils
</p>

 <p>
Emacs Lisp makes it very convenient to batch-edit text files using its
“buffer-editing” model (i.e. scripts can directly reflect interactive
editing).  I find it often much more efficient to write than AWK scripts,
especially with its step-by-step debugging capability.
</p></li>

 <li> <b>Touch-typing:</b> GNU Typist</li>

 <li> <b>Torrent clients:</b> Transmission

 <ul class="org-ul"> <li> <code>Transmission</code> is full-featured and offers various UIs: GTK, Qt, curses,
and… Emacs! ( <code>transmission.el</code>)  Beside not supporting magnet links,
 <code>rtorrent</code> has a poor UI for selecting files and folders manually, which
makes it very impractical for large torrents.  The Emacs interface brings in
its load of usual advantages: extensibility, keyboard-driven, fuzzy-search,
macros, etc.</li>
</ul></li>

 <li> <b>Transcoding:</b> cdparanoia, dvdbackup, FFmpeg, flac, Gaupol, id3v2, libvpx,
MediaInfo, mkvtoolnix, opus, vorbis-tools, wavpack, x264

 <ul class="org-ul"> <li> <code>FFmpeg</code> is the swiss-army knife of transcoding: aspect ratio, concat, crop,
mixdown, remux, metadata, etc.  It is much more efficient to use FFmpeg from a
smart custom script than using a GUI.</li>

 <li> <code>mkvtoolnix</code> can process mkv files in place, e.g. it can instantly change
metadata.</li>

 <li> <code>cdparanoia</code> rips audio CDs.</li>

 <li> <code>dvdbackup</code> decrypts VOB files.</li>

 <li> <code>Gaupol</code> is a simple yet complete subtitle editor.</li>

 <li> <code>MediaInfo</code> displays the media property of pictures, audio and video files
(codecs, container, etc.).  It overlaps a lot with  <code>FFprobe</code> (from  <code>FFmpeg</code>),
but still manages to provide some details that  <code>FFprobe</code> misses.</li>

 <li>The rest is a set of tools for containers and codecs.</li>
</ul></li>

 <li> <b>Translation:</b> translate-shell, Emacs (google-translate)</li>

 <li> <b>Unit conversion:</b> units</li>

 <li> <b>Vector graphics:</b> Asymptote, Graphviz, Inkscape

 <ul class="org-ul"> <li> <code>Asymptote</code> is a full-featured descriptive vector graphics renderer.  It
features libraries for: plots, trees, 3D (with perspective!), and much more.
The language is much more convenient (C-style) and far less limited than its
competitors (TikZ, Metapost, PSTricks): it has double-precision arithmetic
support, control structures, data structures, support for custom structures,
etc.  It also supersedes Gnuplot.</li>

 <li> <code>Graphviz</code> is a smart graph drawing tool that will decide automatically of the
best arrangement for the vertices and edges.</li>

 <li> <code>Inkscape</code> can export to LaTeX, which is useful for good and consistent
typography in your document.</li>
</ul></li>

 <li> <p>
 <b>Version control:</b> git, Emacs (Magit)
</p>

 <p>
I use the  <code>netrc</code> credential system (from  <code>git contrib</code>) to re-use the
credentials stored in my  <code>~/.authinfo.gpg</code> when calling  <code>git send-email</code>.
</p></li>

 <li> <b>Video:</b> mpv, subdl

 <ul class="org-ul"> <li> <code>mpv</code> is a fork of  <code>mplayer</code> with fewer dependencies and some additions such
as an on-screen display, support for resuming and chapter markers.  Both  <code>mpv</code>
and  <code>mplayer</code> allow for very fast video rendering, which can render 1080p
videos on lower-end machines where  <code>VLC</code> would stutter.</li>

 <li> <code>subdl</code> will often fetch the right subtitles for the desired language.  When it
fails to pick the right one, it is still possible to select it manually.</li>
</ul></li>

 <li> <b>Virtual machine hypervisors:</b> QEMU</li>

 <li> <b>Web browsers:</b> Emacs (eww), Nyxt, qutebrowser, surfraw, tor-browser, w3m

 <ul class="org-ul"> <li>While  <code>eww</code> is text-based, it can render variable width/height fonts as well
as pictures.</li>
</ul></li>

 <li> <b>Web tools:</b> curl, Wget, youtube-dl

 <ul class="org-ul"> <li> <code>curl</code> and  <code>Wget</code> are overlapping but also very complementary.</li>

 <li> <code>youtube-dl</code>, as the name does not imply, is not restricted to YouTube.</li>
</ul></li>

 <li> <p>
 <b>Window managers:</b> Emacs (EXWM), Stumpwm
</p>

 <p>
I’ve used  <code>Awesome</code> (extensible in Lua) and  <code>i3</code> (relies on external scripts
for extensibility).  In the end their extensibility was always too limited for
my needs.  For instance it’s very hard (impossible?) to search a window by its
title and directly focus on it.
</p>

 <ul class="org-ul"> <li> <code>EXWM</code> is a WM where all windows are Emacs buffers.  Consequence: you can
fuzzy-select your windows, tile your selection, delete the complementary
selection, etc.  EXWM is obviously extensible in Emacs Lisp.</li>

 <li> <code>Stumpwm</code> is 100% extensible in Common Lisp.  It’s possibly the most
featureful window manager.  It’s less integrated to Emacs, which has its ups
and downs: a blocking Emacs won’t block everything, but it’s harder to link
Emacs content with external applications.</li>
</ul></li>
</ul></div>