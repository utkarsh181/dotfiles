<div id="content">
 <blockquote>
 <p>
Just go ahead and write your own multitasking multiuser os! Worked for me all
the times.
</p>

 <p>
– Linus Torvalds
</p>
</blockquote>

 <div id="outline-container-org9ecc4cb" class="outline-2">
 <h2 id="org9ecc4cb">Abstract</h2>
 <div class="outline-text-2" id="text-org9ecc4cb">
 <p>
This article is mainly based on the French book  <a href="http://www.blaess.fr/christophe/livres/solutions-temps-reel-sous-linux/"> <i>Solution temps réel sous Linux</i></a>
by C. Blaess, chapters 1 to 8.  I have summarized some results of my experiments
while I was playing with the real-time capabilities of the Linux kernel.  I am
far from being an expert in the field, so feel free to  <a href="https://gitlab.com/ambrevar/ambrevar.gitlab.io/issues">send me any
correction/suggestion</a>.
</p>

 <p>
Most of the references mentioned throughout this article refer to the book.
</p>
</div>
</div>

 <div id="outline-container-org4f543b0" class="outline-2">
 <h2 id="org4f543b0">Playground</h2>
 <div class="outline-text-2" id="text-org4f543b0">
 <p>
I wrote a small  <a href="rt.c">test program</a> to display some real-time properties. It should be
straightforward to compile:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ ${CC} -pthread -o rt rt.c
</pre>
</div>

 <p>
Have a look at the comments and the user options: tweaking them will show a
different behaviour.
</p>
</div>
</div>

 <div id="outline-container-orgb92eaa3" class="outline-2">
 <h2 id="orgb92eaa3">Problem overview</h2>
 <div class="outline-text-2" id="text-orgb92eaa3">
 <p>
Real-time programming becomes necessary in a time-constrained context with
various tasks executing in parallel.  It can be useful in various contexts such
as simulation, video games, media stream decoding, etc.
</p>
</div>
</div>

 <div id="outline-container-org72cdacf" class="outline-2">
 <h2 id="org72cdacf">Priorities & niceness</h2>
 <div class="outline-text-2" id="text-org72cdacf">
</div>
 <div id="outline-container-orga0c8f1b" class="outline-3">
 <h3 id="orga0c8f1b">Priorities</h3>
 <div class="outline-text-3" id="text-orga0c8f1b">
 <p>
In real-time, priorities are scaled from 1 to 99 by default, but this is
configurable.  Shared time always has lower priority than real time, as if it
would be of priority 0.
</p>

 <p>
In shared time, the distinction between  <i>niceness</i> and  <i>priority</i> is somewhat
fuzzy.
</p>

 <p>
The niceness goes from -20 to 19, and has a value of 0 by default.  A higher
niceness means a lower priority.  Be aware that priority can be tricky to use:
the scheduler can penalize programs with higher priorities since they run more
often, which leads to programs with lower priority having access to some
resources before.
</p>

 <p>
You need administrative privileges to make use of the real-time scheduler, to
raise the priority or to lower the niceness below the default value.  Otherwise,
this would allow a non-privileged user to paralyze the machine.
</p>

 <p>
Note however that Linux includes a guard on real-time processes.  By default,
lower priority processes still have a little share of time to run.  This is made
so that it is impossible to paralyze the whole system with a simple  <code>while(1);</code>;
albeit severely slowed down, the system can still kill the greedy task.  This
behaviour can be disabled with:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ echo -1 > /proc/sys/kernel/sched_rt_runtime_us
</pre>
</div>
</div>
</div>

 <div id="outline-container-orgd8cc8ac" class="outline-3">
 <h3 id="orgd8cc8ac">Configuration</h3>
 <div class="outline-text-3" id="text-orgd8cc8ac">
 <p>
System resources such as priorities or niceness can be configured in different
places.
</p>

 <ul class="org-ul"> <li>Globally in  <code>/etc/security/limits.conf</code>.</li>
 <li> <code>setrlimit()</code> for a single task.</li>
 <li> <code>ulimit</code> to show some values.</li>
</ul> <p>
See the respective man pages for more details.
</p>
</div>
</div>
</div>

 <div id="outline-container-org4608a3b" class="outline-2">
 <h2 id="org4608a3b">Schedulers</h2>
 <div class="outline-text-2" id="text-org4608a3b">
 <p>
There are several scheduling policies.
</p>

 <ul class="org-ul"> <li>Shared time</li>
 <li>Other (Linux default)</li>
 <li>Batch (Linux only)</li>
 <li>Idle (Linux only)</li>
 <li>Real time</li>
 <li>FIFO</li>
 <li>Round-Robin</li>
</ul> <p>
Linux < 2.6.23 default scheduler was known as the \(O(1)\) scheduler, using priority
lists.  The Completely Fair Schedular (CFS) was merged in Linux 2.6.23: it uses a
red-black tree to choose the next task to run.
</p>

 <p>
Some processus are CPU-bound (intensive computation), other are I/O-bound (a lot
of time is spent on processing the input/output).  The scheduling of tasks in
shared time depends on their use.
</p>

 <ul class="org-ul"> <li>Interactive tasks need a low response time for best user experience.</li>

 <li>Batch processes run in the background; they perform a lot of computation with
little I/O.</li>

 <li>Real-time processes need low response time, minimal variance and should not be
blocked when avoidable.</li>
</ul> <p>
Preemption happens when one of the following condition is met:
</p>

 <ul class="org-ul"> <li>A hardware interrupt was received.</li>
 <li>The end of the time quantum was reached.</li>
 <li>A process with higher priority is active.</li>
</ul></div>

 <div id="outline-container-orga2e161c" class="outline-3">
 <h3 id="orga2e161c">Shared-time</h3>
 <div class="outline-text-3" id="text-orga2e161c">
 <p>
Various commands:
</p>

 <ul class="org-ul"> <li> <code>chrt -m</code>: show current values.</li>
 <li> <code>chrt -ap PID</code>: display PID’s policy and priority, as well as for its current
threads if any.</li>
 <li> <code>ps ma -o command,ni,pri</code> displays the priority and the niceness for various
processes and threads. See the  <code>ps(1)</code> man page.</li>
</ul></div>
</div>

 <div id="outline-container-org8dd76dd" class="outline-3">
 <h3 id="org8dd76dd">RT FIFO</h3>
 <div class="outline-text-3" id="text-org8dd76dd">
 <p>
This is the simplest: first in, first out.  As soon as current task goes into a
waiting state, the next task immediately goes into running state.  It is ideal
for a sequential execution.
</p>
</div>
</div>

 <div id="outline-container-org572cc65" class="outline-3">
 <h3 id="org572cc65">RT Round Robin</h3>
 <div class="outline-text-3" id="text-org572cc65">
 <p>
This allows for  <i>parallel</i> execution of several tasks.  Unlike for the FIFO
scheduler, CPU time slices play a role here (see page 154).  For instance, on IPC
synchronization, time gets wasted if synchronization happens at the beginning of
the time slice. The solution is to use  <code>sched_yield()</code> to control the
scheduling.
</p>
</div>
</div>
</div>

 <div id="outline-container-org2af05eb" class="outline-2">
 <h2 id="org2af05eb">Interrupts</h2>
 <div class="outline-text-2" id="text-org2af05eb">
 <p>
Hardware interrupts cannot be software-managed: it is necessary to work at the
kernel level.  One solution is to write a dedicated module (driver).  The main
advantage of hardware interrupts is to allow for fine-tuning of the execution
order.
</p>

 <p>
Interrupts happen in two steps: the  <i>top half</i> and the  <i>bottom half</i>.  The first
is for the IRQs that are immediately processed and give information to the
latter on how to execute.  This second step can be deferred.
</p>

 <p>
The purpose of this separation is to avoid blocking the processor on an
interrupt for which the bottom half processing is long.
</p>

 <p>
The bottom half processing happens through  <i>tasklets</i>,  <i>workqueues</i>,
 <i>soft-IRQs</i>, or  <i>threaded interrupts</i>.
</p>

 <p>
Interrupts can be displayed from the file  <code>/proc/interrupts</code>.  More precisely, it
can be interesting to display its evolution over time:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ watch -n 1 cat /proc/interrupts
</pre>
</div>

 <p>
(See pages 24, 28, 172.)
</p>

 <p>
Software interrupts happen as soon as a specific instruction runs on the
processor (e.g. division by 0, segmentation fault).  In the general case a signal
is sent to the calling process.
</p>

 <p>
In any case, from the point of view of the process, interrupts consume CPU time.
The time lapse between the moment when they might send a signal and when the
process will actually receive it depends on when the process goes back to its
running state.  Thus it depends on the scheduler.  To make sure that the process
 <i>handler</i> will run before anything else, we must make sure that the process has
maximum priority.
</p>
</div>
</div>

 <div id="outline-container-orgcd3340f" class="outline-2">
 <h2 id="orgcd3340f">Multiprocessors</h2>
 <div class="outline-text-2" id="text-orgcd3340f">
 <p>
A major challenge for scheduling is to handle the multi-CPU case: it is much
more complex to control (i.e. to foresee) the running time of the different
processes.  When working in real time, we are better off to force the application
to work on the same CPU by setting the affinity.  This suggestion does not always
apply, of course.
</p>

 <p>
Some interesting functions worth knowing:
</p>

 <ul class="org-ul"> <li> <i>Linux</i>:  <code>sysconf(_SC_NPROCESSORS_ONLN)</code>: return the number of online
processors.</li>
 <li> <i>GNU</i>:  <code>sched_setaffinity()</code>: change the affinity of a task (process or
thread).  The equivalent for threads is available in the GNU</li>
 <li> <i>pthread</i> library as an extension (and thus non-POSIX).</li>
</ul> <p>
From a shell, the affinity can be tweaked with  <code>taskset -pc CPUNO PID</code>.
</p>
</div>
</div>

 <div id="outline-container-orgc75dfa2" class="outline-2">
 <h2 id="orgc75dfa2">Linux, Linux-rt, and others</h2>
 <div class="outline-text-2" id="text-orgc75dfa2">
</div>
 <div id="outline-container-org4f07d8c" class="outline-3">
 <h3 id="org4f07d8c">Linux</h3>
 <div class="outline-text-3" id="text-org4f07d8c">
 <p>
The standard kernel has been through several evolutions.  Part of the  <code>linux-rt</code>
patch set has been merged into the 2.6 branch, so that the kernel now has a
real-time scheduling policy as well as preemtible system calls.
</p>

 <p>
Kernels before 2.6 are not preemtible.  This can be checked with:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ zcat /proc/config.gz | grep CONFIG_PREEMPT
</pre>
</div>

 <p>
On a 2.6+ kernel:
</p>

 <div class="org-src-container">
 <pre class="src src-conf">CONFIG_PREEMPT_RCU=y
CONFIG_PREEMPT_NOTIFIERS=y
# CONFIG_PREEMPT_NONE is not set
# CONFIG_PREEMPT_VOLUNTARY is not set
CONFIG_PREEMPT=y
CONFIG_PREEMPT_COUNT=y
# CONFIG_PREEMPT_TRACER is not set
</pre>
</div>

 <p>
The command  <code>uname -a</code> also give some hints on the preemption capabilities. See
page 129.
</p>

 <p>
There is no difference in the ABI between the regular  <i>Linux</i> kernel and
 <i>Linux-rt</i>.  It means that there is full binary compatibility.  Why not merging
the Linux-rt branch entirely?  Performance for a personal use happens to be
worse.
</p>
</div>
</div>

 <div id="outline-container-org32cb0cd" class="outline-3">
 <h3 id="org32cb0cd">Linux-rt</h3>
 <div class="outline-text-3" id="text-org32cb0cd">
 <p>
This patch set only changes some kernel parameters and makes system calls even
more preemtible.
</p>

 <p>
Interrupts are as such even more under control, and above all they have less
impact on real-time processes.  For instance, on a Linux machine where all
processors are being used by a real-time application, a  <i>ping flood</i> would halt
the application.  With Linux-rt, the application would continue (perhaps more
slowly).  See page 166.
</p>

 <p>
The main purpose of Linux-rt lies in predictability.  See chapter 8.
</p>
</div>
</div>

 <div id="outline-container-org1698463" class="outline-3">
 <h3 id="org1698463">RTLinux, Xenomai</h3>
 <div class="outline-text-3" id="text-org1698463">
 <p>
Linux and Linux-rt have interesting capabilities in term of  <i>soft real-time</i>.
However, they are almost worthless in a more constrained environment as we
cannot  <i>prove</i> the execution time.  Some Linux-based  <i>hard real-time</i> projects do
exist, though.
</p>

 <ul class="org-ul"> <li> <i>RTLinux</i> is a micro kernel running the entire Linux kernel as a process, thus
it is fully preemptible.  The development of this proprietary kernel has been
discontinued and the source have been released under GPL2.</li>

 <li> <a href="http://xenomai.org/"> <i>Xenomai</i></a> is one of the most active project in the field. It is free and
open-source.</li>
</ul></div>
</div>
</div>
</div>