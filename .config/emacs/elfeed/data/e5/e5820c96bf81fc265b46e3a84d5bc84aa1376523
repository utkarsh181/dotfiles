<div id="content">
 <p>
 <i>This article was initially posted on  <a href="https://www.reddit.com/r/emacs/comments/74hetz/emacs_everywhere/">Reddit</a>.  I’ve revised some arguments by
taking the community feedback into account.</i>
</p>

 <p>
For many years I refrained from using Emacs everywhere because I clung to the
following Unix philosophical principle: “Make each program do one thing well.”
It did not make sense to me then to use a text editor as an e-mail client or a
music library manager.  I used to favour well-established ncurses programs like
Mutt and cmus respectively.
</p>

 <p>
When I started using  <a href="../emacs-eshell">Eshell as my main shell</a>, the benefits of the Emacs
 <i>interface</i> became increasingly obvious.  Maybe my initial reasoning was not well
founded after all.  Since then I successfully moved on to using this
user-interface-on-steroids everywhere.  Looking back, it feels like I had been
missing out and wasted my time for that many years.
</p>

 <p>
This realization is what leads me to write a pamphlet on the matter to help the
user community move forward out of a loop of misconception that does not help
but waste everybody’s time.  I hope to help informing you with strong arguments
as to why you should or you should not use Emacs extensively.
</p>

 <p>
Too often the same fallacious misconceptions stir endless debates:
</p>

 <blockquote>
 <p>
Configuring Emacs cost thousands of hours just to tweak the editor, so sending
e-mails with Emacs is simply not within my reach.
</p>
</blockquote>

 <p>
or, even more famously
</p>

 <blockquote>
 <p>
Emacs is a great operating system, lacking only a decent editor.
</p>
</blockquote>

 <p>
While obviously sarcastic, it might be worth point out that no, Emacs’ intent is
not to be an operating system.  That being said, it is true that Emacs is not
 <i>only</i> an editor.  From a broader perspective, it would be best described as a
 <i>programmable, text-oriented user-interface</i> (containing, among others, an
editor).
</p>

 <p>
As such it is erroneous to discard Emacs special modes for the sole reason that
an editor should not do anything but editing text.  If you think of Emacs as a
user interface, then it covers the same ground as Qt, GTK, Tk or  <i>curses</i> and
the Unix-philosophical argument falls flat.
</p>

 <p>
As a matter of fact, using Emacs to send e-mails or listen to music is usually
 <i>much simpler</i> than configuring the editor.  This is because an editor is
intrisically richer in terms of features and configuration possibilities.
</p>

 <p>
Emacs might not suit everybody’s needs everywhere, although I believe that more
often than not it will.  Hopefully the insights of this pamphlet will add enough
fuel to the fire to help nuance the various views held by the community.
</p>

 <div id="outline-container-orgd6911dc" class="outline-2">
 <h2 id="orgd6911dc">Emacs vs. the others</h2>
 <div class="outline-text-2" id="text-orgd6911dc">
 <p>
The power features Emacs offers and that are lacking in other “common”
interfaces (GTK, Qt, Tk, EFL, cocoa, curses, etc.) include:
</p>

 <ul class="org-ul"> <li>Everything is text, everything is searchable and copy-able.  Even better, you
can fuzzy-search anything.  Enter Helm, Ivy and others.</li>

 <li>It can be fully keyboard-controlled (not very common with GTK and friends),
while mouse controls are supported too (which sucks in ncurses).</li>

 <li>It works both in graphical and textual environments, mostly out-of-the-box.
Nevertheless you should prefer the less limited graphical Emacs: all keyboard
modifiers are supported, various font sizes can be displayed, and… pictures!</li>

 <li>Configuration is done in Emacs Lisp.  Which is the best language ever, as  <a href="http://www.paulgraham.com/avg.html">we
all know</a>.  At least when it comes to  <a href="https://www.gnu.org/software/emacs/emacs-paper.html">extensibility</a>.  And even if you don’t
agree with that, it sucks less than most of its competitors.</li>

 <li>Configuration, as a consequence of being Lisp, can be tracked by version
control systems.</li>
</ul></div>
</div>

 <div id="outline-container-org31424b3" class="outline-2">
 <h2 id="org31424b3">What Emacs really does</h2>
 <div class="outline-text-2" id="text-org31424b3">
 <p>
Now let’s move on to the core of the question: Is it wise to have  <i>everything</i>
run from within Emacs?
</p>

 <p>
A common misconception when thinking of “Emacs as an OS” is to assume that Emacs
special modes are re-inventing the wheel. They are not (for most of them), Emacs
and its modes focus on the  <i>user interface</i> side of things. The backends are
almost always separate programs. This is precisely where the Unix philosophy
still stands strong. Using Emacs as an interface for everything is merely
equivalent to using GTK-only applications. (Only much better, obviously.)
</p>

 <p>
As opposed to other user interfaces Emacs is a  <i>programmable</i> environment: any
structure, interface element and even code can be passed around and combined
between the different interfaces to various programs. Consider those canonical
features:
</p>

 <ul class="org-ul"> <li>Buffers</li>

 <li>The kill-ring</li>

 <li>The “undo” command (or better: undo-tree)</li>

 <li>Macros</li>

 <li>Bookmarks</li>

 <li>Windows</li>

 <li>Abbreviations if that’s your thing</li>

 <li>Snippets if that’s your thing</li>

 <li>Completion</li>

 <li>Spell checking</li>
</ul> <p>
All of them can be applied to (when it makes sense):
</p>

 <ul class="org-ul"> <li>Magit</li>

 <li>Gnus, mu4e, whatever e-mail client you prefer</li>

 <li>Dired, Helm-find-files</li>

 <li>Elfeed, Gnus again</li>

 <li>EMMS</li>

 <li>Org-mode (notes, agenda, contacts, publishing…)</li>
</ul> <p>
And many more.
</p>

 <p>
Emacs does not lure developers into reinventing the wheel, quite the opposite:
it shines at reusing and combining features in the most unexpected ways.
</p>
</div>
</div>

 <div id="outline-container-orge8a68a0" class="outline-2">
 <h2 id="orge8a68a0">The perks of Emacs as a user interface</h2>
 <div class="outline-text-2" id="text-orge8a68a0">
 <p>
There is more to it:
</p>

 <ul class="org-ul"> <li>Since Emacs can display pictures: EMMS can display album covers, e-mails can
display inline attachments.</li>

 <li>Configuration consistency: Bindings, color themes and other interface elements
are consistently shared across the various special modes.  No need to waste
time  <i>syncing the different configuration files of your different programs</i>
(in different configuration languages).</li>

 <li>Configure, extend, fix: With Emacs, everything is configurable, even what was
not foreseen by its developers.  All the Lisp source code is available at hand.
Want to add a feature? It’s usually as simple as adding a few Elisp lines to
the configuration.  Something is broken? After reporting it upstream, you don’t
have to wait for the next release, you can hot-patch the bug from your
configuration.</li>

 <li>Universality.  Emacs is somewhat easy to compile.  It runs on virtually all
desktop platforms you could think of.  As such, running everything from Emacs
effectively abstracts away the OS user interface, which makes it possible to
use your personal configuration on any system.  This is especially useful when
you are forced to a famous crappy OS.</li>

 <li>OS-independent package manager: This provides the user with cutting-edge
packages even on (rusty) conservative distributions or when the user has no
privileges.</li>

 <li>Flatter learning-curve for new programs: Emacs documentation system is (more
or less) consistently used among all Emacs modes, which makes the learning
process of a new mode somewhat easier.  No need to figure out where the static
documentation is (HTML page? man page?), Emacs lets you (fuzzy-)search the
configuration variables and the bindings.</li>

 <li>Lightweight, efficient: When I replaced all my super-lightweight  <i>curses</i>
programs with their Emacs counterparts, I did not notice a significant change
in disk usage.  With the difference that ELPA packages have both the source
code and the byte-compiled files installed.  For programmers and tinkerers,
having source code at hand is a boon.  In terms of performance, graphical Emacs
is not limited by the restrictions born by terminal emulators and inflicted
upon  <i>curses</i> programs.</li>
</ul></div>
</div>

 <div id="outline-container-orgac650e7" class="outline-2">
 <h2 id="orgac650e7">Side effects and other niceties</h2>
 <div class="outline-text-2" id="text-orgac650e7">
 <ul class="org-ul"> <li>Another perk of using Emacs as everything is the  <i>ubiquitous global state</i> of
all Emacs special modes.  Say you want to switch transmission to turtle mode,
there is no need to switch to transmission first, you can invoke the command
or its associated binding directly, regardless of the buffers curretly under
focus.  Same goes for music with EMMS, or anything else running in the
background.</li>

 <li>If you use Eshell, you don’t need that lengthy, clunky bash/zsh/fish
configuration anymore.</li>

 <li>Other cumbersome configurations can go:  <code>dircolors</code>,  <code>lesspipe</code>,
 <code>Xresources</code>…  Even  <code>fzf</code> can be disposed of.</li>

 <li>No need to duplicate your dotfiles for the root user or on remote machines:
use TRAMP!</li>

 <li>“Apps” for web services:  <code>debbugs</code> (to browse the Emacs bug tracker),
 <code>mediawiki-mode</code> to browse and edit MediaWiki-based pages,  <code>sx</code> to work with
StackExchange pages…</li>
</ul></div>
</div>

 <div id="outline-container-orgc1e41e9" class="outline-2">
 <h2 id="orgc1e41e9">EXWM to rule them all</h2>
 <div class="outline-text-2" id="text-orgc1e41e9">
 <p>
 <i>Warning: Aficionados of sparkles and glitter, behold! EXWM is visually as
barren as Emacs gets!</i>
</p>

 <p>
EXWM was for me the last milestone in the course of The Big Shift to a fully
Emacs-based environment.
</p>

 <p>
I’ve been an avid user of AwesomeWM for years, but with time I grew tired of
“losing windows” among the excess of workspaces (tags in Awesome terminology) or
screens.  I wish I could have just fuzzy-searched them with  <code>fzf</code> or something
similar.  I never managed to implement the idea.  Until I discovered EXWM.
</p>

 <p>
EXWM has all the benefits of being Emacs-based with the particularity that all X
windows are buffers and as such are part of Emacs buffer list, which makes for
the capability to fuzzy-select windows with Helm or Ivy!  “Lost windows” belong
to the past.  When opening several windows at once, you can configure how to
display them.  (This is a  <a href="https://github.com/emacs-helm/helm/commit/a66849bfc008bc0082b0a97caa3ac75652f0a8ad">recent addition to Helm</a>.)  A nice use-case is to first
narrow down some windows using Helm patterns, display them all in an “Exposé”
fashion, and finally select your desired windows visually.
</p>

 <p>
Concretely, I have the following bindings:
</p>

 <ul class="org-ul"> <li> <code>s-b</code>:  <code>helm-mini</code></li>
 <li> <code>M-a</code>:  <code>helm-mark-all</code></li>
 <li> <code>s-<hjkl></code>:  <code>windmove-*</code></li>
</ul> <p>
The “Exposé” binding sequence:
</p>

 <pre class="example">
s-b <filter> M-a RET
s-<hjkl> RET
</pre>

 <p>
Say I have a few Wikipedia pages of which I want to want to select one which
title I do not remember:
</p>

 <pre class="example">
s-b wikipedia M-a RET
</pre>

 <p>
Or usually it’s enough with
</p>

 <pre class="example">
s-b wk M-a RET
</pre>

 <p>
then
</p>

 <pre class="example">
s-l s-j RET
</pre>

 <p>
if if’s the second window to the right then down.
</p>

 <p>
Since the window management is extensible, you can write your own
 <code>helm-window-show-buffers-function</code> to fine-tune your needs:
</p>

 <ul class="org-ul"> <li>Always display the compile buffer at the same spot with a specific height.</li>

 <li>If all buffers are web browser windows, pop them up in a mosaic tiling. If
not, use a master-slave tiling.</li>

 <li>Behave differently depending on the number of buffers or depending on the
content or the modes.</li>

 <li>Keep a column of “tools” to the right (calendar, calculator, etc.).</li>
</ul> <p>
It is so convenient to lookup buffers with EXWM+Helm that I’ve quit using
workspaces (a.k.a. tags) altogether in favour of a more global approach.
</p>

 <p>
Maybe one the most noticeable benefit on a daily basis is that it lifts up some
weight off the  <i>cognitive burden</i> of having to manage windows both from Emacs
and from an external window manager. With EXWM, there is no more need to
remember two sets of bindings and windowing rules, the windowing being
effectively fully centralized. For instance I used to reserve the  <code>super</code> key
for all windowing bindings with AwesomeWM; now I reserve it to all Emacs
windowing operations, and there is no need for other bindings.
</p>

 <p>
Adepts of the suckless philosophy would argue that Emacs should leave all
windowing, including its own, to an external specialized program, the window
manager. But from the perspective that Emacs is a user interface, it is not that
much of a heresy to consider that Emacs is precisely  <i>that window manager</i>.
</p>

 <p>
Having Emacs as a window manager has some additional benefits, namely that it is
fully aware of the content of the Emacs buffer, which allows for specializing
windowing actions depending of the different buffers. This is much harder to do
with any other window manager.
</p>
</div>
</div>

 <div id="outline-container-orgceb0247" class="outline-2">
 <h2 id="orgceb0247">Examples and list of programs</h2>
 <div class="outline-text-2" id="text-orgceb0247">
 <ul class="org-ul"> <li>See my  <a href="../">home page</a> for a link to my dotfiles which implement much of these
ideas.</li>

 <li>I keep track of my  <a href="../power-apps">favourite power-user applications</a>, including commandline,
text-mode and Emacs equivalents.</li>
</ul></div>
</div>
</div>