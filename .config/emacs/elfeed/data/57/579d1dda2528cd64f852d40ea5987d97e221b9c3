<div id="content">
 <p>
IDEs provide the user with a lot of neat features beside pure text editing
capabilities: auto-completion, refactoring, project management, etc.  What are
the key features that are really needed? More generally speaking, what makes a
good IDE? Some fancy IDE features are rarely used.  Let’s tackle a few examples.
</p>

 <p>
Refactoring (renaming symbols) is convenient but in practice should happen as
less often as possible.  Avoid the issue altogether by thinking twice before
naming a symbol instead.
</p>

 <p>
Auto-completion certainly stands among the most famous features.  But is it
essential? If we know in advance what we want to write, good touch-typing skills
will often be faster than the time needed for selecting the right item from the
auto-completion list.  (Unless the name is long and cumbersome to write, in which
case auto-completion proves helpful.)
</p>

 <p>
The thinking process “list first, then think about what you want, then select”
is a bad habit: it is slower than “think what you want and write it down”.  More
on that later.
</p>

 <p>
Completion comes in handy, so we think, when listing members of a class.  But if
the class is documented, the list of members should be obvious.  Going to the
definition will provide more documentation than the auto-completion list.  This
falls short in the event of inherited members, or worse, diamond inheritance, in
which case it becomes really hard for a human being to describe an object
mentally or by going to the definition of both its parents and descendants.  Then
a completion framework becomes essential to describe an object.
</p>

 <p>
This solution only applies to ill-designed languages however: a better, more
permanent solution resides in avoiding the use of diamond inheritance in the
first place.  Nothing good can result from not knowing the objects you
manipulate.
</p>

 <div id="outline-container-org4a3def2" class="outline-2">
 <h2 id="org4a3def2">The myth of the  <i>too-good-an-editor</i></h2>
 <div class="outline-text-2" id="text-org4a3def2">
 <p>
 <a href="https://www.gnu.org/software/emacs/">Emacs</a> and  <a href="http://www.vim.org/">Vim</a> have the reputation of the being the geek’s best friends,  <i>the
tools to rule them all</i>.  And yet many professional programmers discard them from
their toolbox to fallback to the “reputable corporate programs.”  Why is that so?
</p>

 <p>
To quote  <a href="http://www.paulgraham.com/avg.html">Paul Graham</a>:
</p>

 <blockquote>
 <p>
“Lisp is worth learning for the profound enlightenment experience you will
have when you finally get it; that experience will make you a better
programmer for the rest of your days, even if you never actually use Lisp
itself a lot.”
</p>

 <p>
This is the same argument you tend to hear for learning Latin.  It won’t get
you a job, except perhaps as a classics professor, but it will improve your
mind, and make you a better writer in languages you do want to use, like
English.
</p>

 <p>
But wait a minute.  This metaphor doesn’t stretch that far.  The reason Latin
won’t get you a job is that no one speaks it.  If you write in Latin, no one
can understand you.  But Lisp is a computer language, and computers speak
whatever language you, the programmer, tell them to.
</p>

 <p>
So if Lisp makes you a better programmer, like he says, why wouldn’t you want
to use it? If a painter were offered a brush that would make him a better
painter, it seems to me that he would want to use it in all his paintings,
wouldn’t he? I’m not trying to make fun of Eric Raymond here.  On the whole,
his advice is good.  What he says about Lisp is pretty much the conventional
wisdom.  But there is a contradiction in the conventional wisdom: Lisp will
make you a better programmer, and yet you won’t use it.
</p>
</blockquote>

 <p>
Questions:
</p>

 <ul class="org-ul"> <li>Why would the big IDEs be more corporate-friendly than the venerable Emacs and
Vim?</li>

 <li>The users of the corporate IDEs argue that Emacs/Vim users sacrifice the
ergonomy and the technical advance of “real” IDEs for the sake of saying
“Look!, I use Emacs/Vim!”.</li>
</ul> <p>
Answers:
</p>

 <ul class="org-ul"> <li>A lot of myths surround us.</li>

 <li>Using Emacs/Vim to its full potential implies learning how to customize it.
The learning curve might be steep.  Thus it is not so apparent  <i>at first</i> how
Emacs/Vim can overtake the big IDEs.  A naive use of those editors will seem
very tedious and unproductive.</li>

 <li>One of the strongest selling point for IDEs in corporate environments is that
they are supposed to have an out-of-the-box UI, thus avoiding costly training
programs for using the more geeky editors.</li>

 <li>As Paul Graham hints it, there is a popular misconception that too powerful
tools can be nice fooling around with, but they better stay out of the way of
the professional case.</li>
</ul> <p>
I can recall the times when I was studying, our dean would say (and write in the
syllabus):
</p>

 <blockquote>
 <ul class="org-ul"> <li>Nano: a simple editor</li>
 <li>Vim: an advanced editor</li>
 <li>Emacs: too-powerful an editor</li>
</ul></blockquote>
</div>
</div>

 <div id="outline-container-org950ea3e" class="outline-2">
 <h2 id="org950ea3e">Fundamental editing</h2>
 <div class="outline-text-2" id="text-org950ea3e">
 <p>
What is the one feature we need from a text editor?
</p>

 <p>
Have you ever faced a one-time situation where you wished that the editor could
automatically do this and that? Something specific enough that you know nobody
will ever be in such a situation again.  Like remove all the roman numerals at
the beginning of every two paragraphs, or remove the XML tags while keeping a
subset of it?
</p>

 <p>
No editor developer can predict what use the user will make of it.  Boosting the
user’s productivity by implementing every single corner case of editing
capabilities is not possible.
</p>

 <p>
As such, an editor needs just one core feature to boost the productivity of
 <i>every</i> user:
</p>

 <blockquote>
 <p>
Be an extensible editor.
</p>
</blockquote>

 <p>
That’s it.  Well, let’s add some frivolities to the list:
</p>

 <ul class="org-ul"> <li>Any action can be bound to a keyboard shortcut.</li>
</ul> <p>
Touch-typing is what will make you write code  <i>fast</i>, not fancy IDE features.
Mouse actions will disrupt the flow which is why a keyboard-oriented editor will
allow for a faster flow.  See  <a href="../keymap/index.html">Mastering the keyboard</a>.
</p>

 <ul class="org-ul"> <li>Capable of running in text mode (e.g. TTY) is a plus for historical reasons.</li>
</ul> <p>
Text mode is not strictly required, but as of 2016 it is still prevalent in many
contexts in which you really want to keep your favorite tool at hand.
</p>

 <p>
Extensibility alone implies many features commonly found in other editors.  For
instance:
</p>

 <ul class="org-ul"> <li>Syntax highlighting (some don’t like it).</li>
 <li>Compilation feedback (go to error, etc.).</li>
 <li>Advanced character editing (capitalize, etc.).</li>
 <li>Keyboard macros.</li>
 <li>Automatic indentation.</li>
 <li>Regexp support (search and replace).</li>
 <li>Rectangular selection and editing.</li>
 <li>Abbreviation expansion.</li>
 <li>Auto-completion.</li>
 <li>Spell checking.</li>
 <li>Fully keyboard controlled, without relying on arrows. (This would disrupt the
flow when the hands are on the homerow.)</li>
 <li>Fast navigation (function, paragraph, word, matching parenthesis, page,
search, etc.).</li>
 <li> <a href="http://emacsrocks.com/e13.html">Multiple cursors</a>.</li>
 <li>Shell piping (output to buffer), call shell commands on files and process
output.</li>
 <li>Display editing windows side-by-side, including of the same document.</li>
 <li>Templates / snippets.</li>
 <li>Whitespace management, automatic code formatting.</li>
 <li>Fast buffer switching. (Tabs are slow to browse.)</li>
 <li>Fullscreen text editing area.  This is where you’ll spend most of your time
reading and writing.  Paradoxically, some IDEs forget they should be  <i>editors</i>
before anything else and bundle so many features in side windows that the text
area is less than half the screen space by default.</li>
</ul> <p>
Text editors that are extensible, keyboard controlled and work in text mode are
not legions.  The most popular are, by far, the ancient, legendary Emacs and
Vim.   <a href="https://foicica.com/textadept/">TextAdept</a> is another one that offers some interesting feats.
</p>

 <p>
Vim inherits from  <code>vi</code>, a historical text editor that is very minimalist.  Both
editors are sometimes mixed up, in so far as some systems actually symlink  <code>vi</code>
to Vim.  This is dangerous so let’s stress this out: if you find yourself
wondering why so many people follow the Cult of Vim while it seems to be the
most limited editor you’ve ever encountered, you might be using the wrong piece
of software.
</p>

 <p>
The war between Emacs and Vim is, in my opinion, futile.  To the point that Emacs
has a mode to emulate Vim.  Both editors have all the fundamental features: a
Turing-complete configuration that allows for binding any action to keyboard
shortcuts.  (Plus they run in text mode.)
</p>

 <p>
Maybe the only significant difference between the two is that Emacs uses Emacs
Lisp as a configuration language while Vim uses Vimscript.
</p>

 <p>
Another difference is that Emacs has a greedy tendency for bundling its
community extensions (for the sake of GPL3 protection?) while Vim keeps it
slightly lighter.
</p>
</div>

 <div id="outline-container-orgdbf00f4" class="outline-3">
 <h3 id="orgdbf00f4">Learning curve</h3>
 <div class="outline-text-3" id="text-orgdbf00f4">
 <p>
An editor is not the easiest tool to master.  It takes time getting used to the
bindings.  It will only start proving efficient once the bindings have been
hard-wired to your brain.
</p>

 <p>
But this is not what matters most.  The hardest part will be to become
comfortable at customizing the editor, that is, learning the scripting language
and the editor API to make it fit all your needs.  And your needs will become
legions over the years.
</p>
</div>
</div>

 <div id="outline-container-orge4a08eb" class="outline-3">
 <h3 id="orge4a08eb">Bindings</h3>
 <div class="outline-text-3" id="text-orge4a08eb">
 <p>
The venerable  <code>vi</code> has left its mark in computer history: its modal approach has
inspired many unrelated programs to use its bindings.  Getting familiar with the
basics of  <code>vi</code> will help using many programs smoothly.
</p>

 <p>
Emacs has generated a similar phenomenon, maybe a tad more limited.  Some tools
(shells, Matlab) also offer Emacs key bindings.
</p>

 <p>
This had become prevalent to the point that bindings can be classified into
families:
</p>

 <ul class="org-ul"> <li>vi</li>
 <li>Emacs</li>
 <li>CUA</li>
</ul> <p>
CUA are the bindings that IBM had laid down in the 1980s and that are now (2016)
considered “standard”:  <code>Ctrl-c</code>,  <code>Ctrl-v</code> and the like.  If you think that Emacs
and  <code>vi</code> go “against the rule”, note that they were first…
</p>

 <p>
Switching from a keybinding family to another can be disturbing: I personally
try to stick to one as much as possible.  Which also means that it might be a
good idea not to change the default bindings of the most common actions within
Emacs and Vim.  That is more a matter of personal taste though.
</p>
</div>
</div>

 <div id="outline-container-org13c1307" class="outline-3">
 <h3 id="org13c1307">Versionable configuration</h3>
 <div class="outline-text-3" id="text-org13c1307">
 <p>
Last but not least, an extensible text editor means you will want to save and
sync your configuration across machines.  If the configuration is not saved in a
versionable format, the editor is not an acceptable tool for the purpose.
</p>
</div>
</div>
</div>

 <div id="outline-container-org374e679" class="outline-2">
 <h2 id="org374e679">Project editing</h2>
 <div class="outline-text-2" id="text-org374e679">
 <p>
Using a text editor a programmer is often bound to managing big sets of files
for each projects.  This has set the need for IDEs.  But not so fast. What is most
needed?
</p>

 <p>
Building the project? A console to run the build command will do.  (Calling it
from the text editor can be a plus if the error output can direct to the
spurious files and lines.)
</p>

 <p>
Versioning? Use your favorite interface to the VCS, there is little need for
interfacing it from the text editor.
</p>

 <p>
File browsing? There are efficient ways for doing that (better than just a file
tree) within or outside a text editor.  More on that later.
</p>

 <p>
What you will need most in big projects:
</p>

 <blockquote>
 <p>
Surfing the whole code base as fast as possible.
</p>
</blockquote>

 <p>
It is not only about finding files, it is about finding chunks of code.  With
little typing and little cognitive effort.  When you write code, you actually
spend a lot of time reading the existing code:
</p>

 <ul class="org-ul"> <li>Looking for comments.</li>
 <li>Looking for functions, types, etc.</li>
 <li>Checking out algorithms.</li>
 <li>Looking for files as a whole (head comment and content).</li>
</ul></div>

 <div id="outline-container-org246114a" class="outline-3">
 <h3 id="org246114a">Incremental narrowing search</h3>
 <div class="outline-text-3" id="text-org246114a">
 <p>
Above we mentioned the following thinking process: “list first, then think about
what you want, then select”.  This is counter-productive since you should know
what you are looking for beforehand.  I advocate for the following, more
productive mindset: “think what you want and write it down”.  This allows for a
different UI approach.
</p>

 <p>
The “classic” UI design bound the the former thinking process is made of lists
of objects the user is looking for: file lists, buffer lists, text search lists,
etc.  The user browses them and picks the desired items.
</p>

 <p>
 <i>Incremental narrowing search</i> is a much more productive design reflecting the
latter mindset: the list of results is filtered as you type while it is ordered
by best match.  The typed text needs only be approximate.  Which makes it very
fast to look for anything, should you know the exact name, remember part of it,
or just be looking for some keywords.
</p>

 <p>
Implementations of such UI designs include  <a href="https://github.com/junegunn/fzf">fzf</a> and  <a href="https://emacs-helm.github.io/helm/">Emacs Helm</a>.  <code>fzf</code> runs from
the shell, it will let you search files, shell history and so on.  Emacs Helm is
similar but runs for any lookup action within Emacs.
</p>

 <p>
The strong point of this design is its universality: it is not specific to one
action, it can be used pretty much anywhere the user can make a request with
words:
</p>

 <ul class="org-ul"> <li>Looking for content (most important!).</li>
 <li>Looking for commands.</li>
 <li>Looking for files.</li>
 <li>Looking for functions and declarations in code (methods, attributes…).</li>
 <li>Looking for a buffer.</li>
 <li>Looking for a man page.</li>
 <li>Looking for an entry in some command history or in the copy-paste clipboard.</li>
 <li>You name it!</li>
</ul> <p>
 <a href="http://www.youtube.com/watch?v=4XpnKHJAok8">Linus Torvalds on git</a>:
</p>

 <blockquote>
 <p>
It’s the content that matter, it’s not actually the files.
</p>
</blockquote>

 <p>
It is most important to be able to browse your project by content as it should
not matter if a portion of code got moved to another file.
</p>

 <p>
It is also a cheap way to find references: forcing exact matches with a regexp
like  <code>\<name\></code> will make it reasonably accurate.
</p>

 <p>
It is an inefficient  <code>go to definition</code> however, which only proves useful if you
don’t have any semantic analysis at hand for your programming language.
</p>
</div>
</div>

 <div id="outline-container-org1c2219b" class="outline-3">
 <h3 id="org1c2219b">Go to definition</h3>
 <div class="outline-text-3" id="text-org1c2219b">
 <p>
I used to work for a company that was working on a massive code base.  On my
first day I was told “disable auto-completion and all those cumbersome, slow
features, then activate  <code>go to definition</code>.”  As a matter of fact, all
programmers in the company were using and abusing of this one feature, almost
exclusively.  Since the code base was immense and the documentation somewhat
lacking (don’t be surprised…), contributing to the code-base implied reading
big portions of the existing code and thus going down the huge hierarchy of
structures and functions.
</p>

 <p>
 <code>Go to definition</code> proved to be by far the most useful navigation function.  If
the code base is well written, a glimpse at the definition will give you a full
understanding of the functions you are calling and the data structures you are
manipulating, both from comments and code.  When badly written (lacking in
clarity or comments…), you can jump straight to the code to decrypt what it
truly does!
</p>
</div>
</div>
</div>
</div>