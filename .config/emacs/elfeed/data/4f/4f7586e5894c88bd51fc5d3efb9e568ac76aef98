<div id="content">
 <p>
C was designed with simplicity in mind.  Despite this, C has a lot of dark
corners that are not necessarily well known.  Here follows an incomplete
collection of them.
</p>

 <p>
For historical reasons, we also include some C++ intricacies that may be source
of confusion when writing C programs.
</p>

 <div id="outline-container-org65f50d8" class="outline-2">
 <h2 id="org65f50d8">Constancy</h2>
 <div class="outline-text-2" id="text-org65f50d8">
</div>
 <div id="outline-container-org19f9c49" class="outline-3">
 <h3 id="org19f9c49">Constant definition</h3>
 <div class="outline-text-3" id="text-org19f9c49">
 <p>
The  <code>const</code> key word always applies to  <i>the identifier to the left</i>, when any,
or to the right otherwise.
</p>

 <p>
Both following lines declare a pointer over a constant integer.
</p>

 <div class="org-src-container">
 <pre class="src src-C">const int * pi;
int const * pi;
</pre>
</div>

 <p>
The following, however, declares a constant pointer over an integer.
</p>

 <div class="org-src-container">
 <pre class="src src-C">int * const pi;
</pre>
</div>

 <p>
Pay special attention when declaring pointers to arrays because of the operator
precedence.  Here we have an array of 12 pointers to constant integers.
</p>

 <div class="org-src-container">
 <pre class="src src-C">const int *pi[12];
</pre>
</div>

 <p>
The next one is a pointer to an array of 12 constant integers.
</p>

 <div class="org-src-container">
 <pre class="src src-C">const int (*pi)[12];
</pre>
</div>

 <p>
It is always possible to make something constant, but the opposite is not true.
</p>

 <p>
In C++, it is possible to add the  <code>const</code> key word next to a method prototype to
specify that it will not modify the attributes.
</p>
</div>
</div>

 <div id="outline-container-org0ff2a12" class="outline-3">
 <h3 id="org0ff2a12">Constant pointers</h3>
 <div class="outline-text-3" id="text-org0ff2a12">
 <p>
The following is forbidden:
</p>

 <div class="org-src-container">
 <pre class="src src-C">char *pc;
const char **ppc;

ppc = &pc; // Forbidden!
</pre>
</div>

 <p>
This would break the constancy rule, since it would be possible to change
 <code>**ppc</code> value through  <code>*pc</code>.
</p>

 <p>
Suppose it would not be forbidden:
</p>

 <div class="org-src-container">
 <pre class="src src-C">const char c = 'a';      // Constant variable.
char *pc;                // Pointer through which we will change c.
const char **ppc = &pc;  // Forbidden, but assume it is not.

*ppc = &c;               // Legal.
*pc = 'b';               // Change c.
</pre>
</div>

 <p>
So  <code>ppc</code> goes through  <code>pc</code> to  <code>c</code>.  Since  <code>pc</code> is not a pointer to a constant, we
can change the value, thus  <code>ppc</code> constancy is broken.
</p>
</div>
</div>

 <div id="outline-container-org4ffe72a" class="outline-3">
 <h3 id="org4ffe72a">C/C++ difference for  <code>const</code></h3>
 <div class="outline-text-3" id="text-org4ffe72a">
 <p>
In C, the following
</p>

 <div class="org-src-container">
 <pre class="src src-C">const int a = 10;
int *p = &a;
*p = 30;

printf("&a: %u, a: %d\n", &a, a);
printf("&p: %u, p: %d\n", p, *p);
return 0;
</pre>
</div>

 <p>
outputs as expected
</p>

 <pre class="example">
&a: 1021510500, a: 30
&p: 1021510500, p: 30
</pre>

 <p>
But in C++, the previous code won’t be allowed since the  <code>const</code> keyword is more
restrictive.  There is a workaround though:
</p>

 <div class="org-src-container">
 <pre class="src src-C++">const int a = 10;
int *p = (int*)(&a);
*p = 30;

printf("&a: %u, a: %d\n", &a, a);
printf("&p: %u, p: %d\n", p, *p);
</pre>
</div>

 <p>
but the output will be:
</p>

 <pre class="example">
&a: 1021510500, a: 10
&p: 1021510500, p: 30
</pre>

 <p>
Yes, that is the same address and two different values!
</p>

 <p>
This is because C++ handles  <code>const</code> as an immediate value, not a variable.  It
behaves similarly to  <code>#define</code>.  The address of a  <code>const</code>, albeit grammatically
defined, is rather meaningless.
</p>
</div>
</div>

 <div id="outline-container-orgd7ec88b" class="outline-3">
 <h3 id="orgd7ec88b">Constants as static array initializers</h3>
 <div class="outline-text-3" id="text-orgd7ec88b">
 <p>
Semantically speaking, the  <code>const</code> keyword refers to  <i>immutable variables</i> and
not  <i>constant variables</i>, which is an interesting oxymoron.
</p>

 <p>
As such,  <code>const</code> variables should not be used to initialize static arrays of
some size, since the standard requires a semantic constant here, i.e. an integer
or a preprocessor expression that expands to an integer.
</p>

 <div class="org-src-container">
 <pre class="src src-C">int array1[17];
const unsigned int sz = sizeof array1;
int array2[sizeof array1]; // OK
int array3[sz]; // Wrong
</pre>
</div>

 <p>
In practice, most compilers accept  <code>const</code> variables in that case.
</p>
</div>
</div>
</div>

 <div id="outline-container-orgfbc73eb" class="outline-2">
 <h2 id="orgfbc73eb">Function argument evaluation order</h2>
 <div class="outline-text-2" id="text-orgfbc73eb">
 <p>
From  <i>The C Programming Language</i>:
</p>

 <blockquote>
 <p>
The order in which function arguments are evaluated is unspecified, so the
statement printf(“%d %d\n”, ++n, power(2, n)); can produce different results
with different compilers, depending on whether n is incremented before power is
called.
</p>
</blockquote>

 <p>
Thus it is good practice to avoid expressions in function calls.
</p>
</div>
</div>

 <div id="outline-container-org313145a" class="outline-2">
 <h2 id="org313145a">Arrays</h2>
 <div class="outline-text-2" id="text-org313145a">
 <p>
Arrays are  <i>not</i> pointers! There is a small number of cases when they behave
differently.  The following test is true:
</p>

 <div class="org-src-container">
 <pre class="src src-C">array[0] == *array
</pre>
</div>

 <p>
From the  <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">C standard</a>:
</p>

 <blockquote>
 <p>
Except when it is the operand of the  <code>sizeof</code> operator, the  <code>_Alignof</code> operator,
or the unary  <code>&</code> operator, or is a string literal used to initialize an array,
an expression that has type “array of type” is converted to an expression with
type “pointer to type” that points to the initial element of the array object
and is not an lvalue.  If the array object has register storage class, the
behavior is undefined.
</p>
</blockquote>
</div>

 <div id="outline-container-orgb13f2fe" class="outline-3">
 <h3 id="orgb13f2fe">Using  <code>sizeof</code></h3>
 <div class="outline-text-3" id="text-orgb13f2fe">
 <p>
The  <code>sizeof</code> operator is dynamic and follows its own set of rules as described
by the standard.  When the argument is an array, it will return the total number
of bytes.
</p>

 <div class="org-src-container">
 <pre class="src src-C">long array[3];
long *p = array;
printf("%zu\n", sizeof(array));
printf("%zu\n", sizeof(p));
</pre>
</div>

 <p>
On machines where  <code>long</code> is 8 bytes and pointers are 4 bytes, this will output:
</p>

 <pre class="example">
24
4
</pre>

 <p>
Arrays are automatically converted to pointers in function arguments.  Thus the
behavior of  <code>sizeof</code> is special only within the scope of an array declaration.
</p>

 <div class="org-src-container">
 <pre class="src src-C">void foo(int array[]) {
    printf("foo: sizeof array == %zu\n", sizeof array);
}

void bar(int array[12]) {
    printf("bar: sizeof array == %zu\n", sizeof array);
}

int main() {
    int array[10];

    printf("main: sizeof array == %zu\n", sizeof array);
    foo(array);
    bar(array);

    return 0;
}
</pre>
</div>

 <p>
For multidimensional arrays, only the outermost dimension is converted to a
pointers.  For instance,  <code>int array[M][N]</code> will be cast to  <code>int (*)[N]</code>.  The
following will output the size of a pointer.
</p>

 <div class="org-src-container">
 <pre class="src src-C">void foo(int *array[3]) {
    printf("foo: sizeof array == %zu\n", sizeof array);
}

int main() {
    int arr[2][3] = {{10, 20, 30}, {40, 50, 60}};
    foo(arr);
    return 0;
}
</pre>
</div>
</div>
</div>

 <div id="outline-container-orga14e975" class="outline-3">
 <h3 id="orga14e975">Addressing arrays</h3>
 <div class="outline-text-3" id="text-orga14e975">
 <p>
Arrays have a type signature that differs from pointers.  The signature of a
pointer to an n-array of T is  <code>T (*)[n]</code>.
</p>

 <div class="org-src-container">
 <pre class="src src-C">long array[3];
long *p;
long **pp;
long (*ap)[3];

p = &array;  // Wrong
pp = &array; // Wrong
ap = &array; // OK
</pre>
</div>

 <p>
Note that the warning about type comes from the dereferences ( <code>&</code>), since the
following code does not prompt any warning:
</p>

 <div class="org-src-container">
 <pre class="src src-C">long array[3];
long *p;
long (*ap)[3];

p = array;   // OK this time
ap = &array; // OK
</pre>
</div>

 <p>
Conversely, a pointer cannot be assigned to an array:
</p>

 <div class="org-src-container">
 <pre class="src src-C">long array[3];
long *p;
array = p; // Wrong
</pre>
</div>
</div>
</div>

 <div id="outline-container-orgc9b14af" class="outline-3">
 <h3 id="orgc9b14af">Arrays as strings</h3>
 <div class="outline-text-3" id="text-orgc9b14af">
 <p>
Arrays can only be initialized with semantic constants.
</p>

 <div class="org-src-container">
 <pre class="src src-C">char *p = "hello";
char t0[] = "world";
char t1[] = {'f', 'o', 'o'};
char t2[] = p; // Error.
char t3[] = (char*) "foo"; // Error.
</pre>
</div>

 <p>
There is another  <i>major</i> difference in the initialization of pointers against
arrays.  The pointer will only set its value to the address of  <code>hello</code> stored in
the static memory segment of the program, whereas the array will copy  <code>world</code>
from this same segment to its allocated memory.  The array can be modified
afterwards, unlike the underlying value of the pointer.
</p>
</div>
</div>
</div>

 <div id="outline-container-org1f4ada1" class="outline-2">
 <h2 id="org1f4ada1">Implicit cast</h2>
 <div class="outline-text-2" id="text-org1f4ada1">
 <p>
Numbers are automatically upcast in function calls.  Compare
</p>

 <div class="org-src-container">
 <pre class="src src-C">unsigned char a = 255;
a++;
printf("%d\n", a);
</pre>
</div>

 <p>
and
</p>

 <div class="org-src-container">
 <pre class="src src-C">unsigned char a = 255;
printf("%d\n", a+1);
</pre>
</div>

 <p>
There is no loss of information during an upcast, except for the  <code>char</code> type.  C
does not specify whether a  <code>char</code> should be signed.  Thus  <code>signed</code> or  <code>unsigned</code>
should be used to ensure portability.
</p>

 <p>
From  <i>The C Programming Language</i>, section 2.7:
</p>

 <blockquote>
 <p>
Conversion rules are more complicated when unsigned operands are involved.  The
problem is that comparisons between signed and unsigned values are
machine-dependent, because they depend on the sizes of the various integer
types.  For example, suppose that  <code>int</code> is 16 bits and long is 32 bits.  Then  <code>-1L
< 1U</code>, because 1U, which is an  <code>int</code>, is promoted to a signed long.  But  <code>-1L >
1UL</code>, because  <code>-1L</code> is promoted to unsigned long and thus appears to be a large
positive number.
</p>
</blockquote>

 <p>
See appendix A6 in the book for more implicit conversion rules.
</p>
</div>
</div>

 <div id="outline-container-org49e4111" class="outline-2">
 <h2 id="org49e4111">Bit shifting</h2>
 <div class="outline-text-2" id="text-org49e4111">
 <p>
Be wary of the difference between a  <i>logical shift</i> and an  <i>arithmetic shift</i>.
See  <a href="https://en.wikipedia.org/wiki/Arithmetic_shift">this Wikipedia article</a> for more details.  Note that it only matters for right
shifting.
</p>

 <p>
The C behaviour is architecture-dependent for signed numbers.
</p>
</div>
</div>

 <div id="outline-container-org44cdbf2" class="outline-2">
 <h2 id="org44cdbf2">Modulo operation</h2>
 <div class="outline-text-2" id="text-org44cdbf2">
 <p>
In C99, the result of a modulo operation has the sign of the dividend:
</p>

 <div class="org-src-container">
 <pre class="src src-C">printf("-5 % 2 = %d\n", -5 % 2);
printf("5 % -2 = %d\n", 5 % -2);
</pre>
</div>

 <p>
To test whether an integer is odd, you must compare to 0, not 1.  Otherwise, the
result will be incorrect when the dividend is negative.
</p>

 <div class="org-src-container">
 <pre class="src src-C">if (n % 2 == 1) // WRONG!
if (n % 2 != 0) // Correct.
</pre>
</div>
</div>
</div>

 <div id="outline-container-org9f08e2e" class="outline-2">
 <h2 id="org9f08e2e">Operator precedence</h2>
 <div class="outline-text-2" id="text-org9f08e2e">
 <p>
The choice for operator precedence in C can be counter-intuitive at times.  The
expression  <code>a & b == 7</code> is parsed as  <code>a & (b == 7)</code>.
</p>

 <p>
See  <a href="https://en.wikipedia.org/wiki/Operators_in_C_and_C++#Operator_precedence">this Wikipedia article</a> for more details.
</p>
</div>
</div>

 <div id="outline-container-orgdce714a" class="outline-2">
 <h2 id="orgdce714a">File reading</h2>
 <div class="outline-text-2" id="text-orgdce714a">
 <p>
When a text file is open in text-mode, (e.g. using the  <code>"r"</code> option), POSIX
specifies that the  <code>"b"</code> option is ignored.  Some non-POSIX operating systems,
however, may try to be too smart.  They will expect a “standard” end-of-line,
such as  <code>\r\n</code>.  Which will obviously produce unexpected results on files with
 <code>\n</code> line breaks.  The  <code>"b"</code> option does not harm and helps for portability.
</p>
</div>
</div>

 <div id="outline-container-orgde9d7bd" class="outline-2">
 <h2 id="orgde9d7bd">Globals</h2>
 <div class="outline-text-2" id="text-orgde9d7bd">
 <p>
Pre-declarations can appear any number of times in C.  They can appear only once
in C++, or the compiler will complain about double definitions of globals:
</p>

 <div class="org-src-container">
 <pre class="src src-C">#include <stdio.h>

int global;
int global;
int global = 3;

void change() {
    global = 17;
}

int main() {
    printf("%d\n", global);
    change();
    printf("%d\n", global);
    return 0;
}
</pre>
</div>

 <p>
In C, it will display the following:
</p>

 <pre class="example">
3
17
</pre>
</div>
</div>

 <div id="outline-container-org08f36ff" class="outline-2">
 <h2 id="org08f36ff">Pointer arithmetic</h2>
 <div class="outline-text-2" id="text-org08f36ff">
 <p>
It is not safe to assume that pointer arithmetic results in any integral type.
Some architectures may have memory addresses indexed over 64-bit values, while
using data over 32 bits.  This behavior can be controlled from  <code>stdlib.h</code>.  For
example, a pointer difference is stored as a type  <code>ptrdiff_t</code>.
</p>
</div>
</div>

 <div id="outline-container-orgcbaa92c" class="outline-2">
 <h2 id="orgcbaa92c">Size of void</h2>
 <div class="outline-text-2" id="text-orgcbaa92c">
 <p>
With GCC,  <code>sizeof(void) == 1</code> is true.  This is non standard, but the behaviour
is not clearly specified either.  Using  <code>-pedantic</code> will output a warning.
</p>
</div>
</div>

 <div id="outline-container-orgda4276e" class="outline-2">
 <h2 id="orgda4276e">Alignment</h2>
 <div class="outline-text-2" id="text-orgda4276e">
 <p>
Do not expect the memory layout in structures to be as the code describes it:
the compiler is free to pad some memory for optimization purposes.
</p>

 <p>
This proves dangerous when serializing data.  Use the  <code>offsetof</code> macro to get the
real offset of each structure member.
</p>

 <div class="org-src-container">
 <pre class="src src-C">struct {char a; int b;} foo;
struct {char a; char b;} bar;

printf("sizeof foo == %zu\n", sizeof foo);
printf("&foo == %p\n", &foo);
printf("&foo.a == %p\n", &foo.a);
printf("&foo.b == %p\n", &foo.b);

printf("sizeof bar == %zu\n", sizeof bar);
printf("&bar == %p\n", &bar);
printf("&bar.a == %p\n", &bar.a);
printf("&bar.b == %p\n", &bar.b);
</pre>
</div>
</div>
</div>

 <div id="outline-container-orgf1c3ad6" class="outline-2">
 <h2 id="orgf1c3ad6">Precompiled headers</h2>
 <div class="outline-text-2" id="text-orgf1c3ad6">
 <p>
Compiling a header file may yield an unexpected result: some compilers such as
GCC will recognize the extension and act accordingly.  In that case, building a
header will not result in an executable, but in a  <i>precompiled header</i>, that is,
an optimization for large headers.
</p>

 <p>
If you want to force or prevent the build of precompiled headers, GCC allows for
specifying the input language:
</p>

 <div class="org-src-container">
 <pre class="src src-sh"># The .xml file will be seen as a C header file.
gcc -x c-header myfile.xml
# The .h file will be compiled into an executable.
gcc -x c myfile.h
</pre>
</div>
</div>
</div>

 <div id="outline-container-org99d41b9" class="outline-2">
 <h2 id="org99d41b9">Final note</h2>
 <div class="outline-text-2" id="text-org99d41b9">
 <p>
The numerous dark corners of C require some getting used to.  It is helpful and
good practice to make heavy use of your compiler’s warning flags, together with
some fine “lint” tools.
</p>
</div>
</div>

 <div id="outline-container-org88f45b3" class="outline-2">
 <h2 id="org88f45b3">References</h2>
 <div class="outline-text-2" id="text-org88f45b3">
 <ul class="org-ul"> <li>BSD/GNU man pages</li>
 <li>The C Programming Language, D. Ritchie & B. Kernighan</li>
 <li> <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">Draft of the C standard</a></li>
 <li> <a href="https://en.wikipedia.org/wiki/Arithmetic_shift">Wikipedia/Arithmetic shift</a></li>
 <li> <a href="https://en.wikipedia.org/wiki/Operators_in_C_and_C++#Operator_precedence">Wikipedia/Operator precedence</a></li>
 <li> <a href="https://en.wikipedia.org/wiki/Type_conversion">Wikipedia/Type conversion</a></li>
 <li> <a href="https://modelingwithdata.org/arch/00000022.htm">Better variadic functions for C</a></li>
 <li> <a href="https://www-s.acm.illinois.edu/webmonkeys/book/c_guide/">The C Library Reference Guide</a></li>
</ul></div>
</div>
</div>