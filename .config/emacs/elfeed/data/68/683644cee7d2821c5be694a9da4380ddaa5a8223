<div id="content">
 <p>
 <i>This article was initially posted on  <a href="http://www.gnu.org/software/guix/blog/2018/a-packaging-tutorial-for-guix/">Guix’ blog</a>.</i>
</p>

 <div id="outline-container-org7303a84" class="outline-2">
 <h2 id="org7303a84">Introduction</h2>
 <div class="outline-text-2" id="text-org7303a84">
 <p>
GNU Guix stands out as the  <i>hackable</i> package manager, mostly because it uses
 <a href="https://www.gnu.org/software/guile/">GNU Guile</a>, a powerful high-level programming language, one of the  <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>
dialects from the  <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp family</a>.
</p>

 <p>
Package definitions are also written in Scheme, which empowers Guix in some very
unique ways, unlike most other package managers that use shell scripts or
simple languages.
</p>

 <ul class="org-ul"> <li>Use functions, structures, macros and all of Scheme expressiveness for your
package definitions.</li>

 <li>Inheritance makes it easy to customize a package by inheriting from it and
modifying only what is needed.</li>

 <li>Batch processing: the whole package collection can be parsed, filtered and
processed.  Building a headless server with all graphical interfaces stripped
out?  It’s possible.  Want to rebuild everything from source using specific
compiler optimization flags?  Pass the  <code>#:make-flags "..."</code> argument to the
list of packages.  It wouldn’t be a stretch to think  <a href="https://wiki.gentoo.org/wiki/USE_flag">Gentoo USE flags</a> here,
but this goes even further: the changes don’t have to be thought out
beforehand by the packager, they can be  <i>programmed</i> by the user!</li>
</ul> <p>
The following tutorial covers all the basics around package creation with Guix.
It does not assume much knowledge of the Guix system nor of the Lisp language.
The reader is only expected to be familiar with the command line and to have some
basic programming knowledge.
</p>
</div>
</div>

 <div id="outline-container-org4d9bca5" class="outline-2">
 <h2 id="org4d9bca5">A “Hello World” package</h2>
 <div class="outline-text-2" id="text-org4d9bca5">
 <p>
The  <a href="https://www.gnu.org/software/guix/manual/en/html_node/Defining-Packages.html">“Defining Packages” section of the manual</a> introduces the basics of Guix
packaging.  In the following section, we will partly go over those basics again.
</p>

 <p>
 <code>GNU hello</code> is a dummy project that serves as an idiomatic example for
packaging.  It uses the GNU build system ( <code>./configure && make && make install</code>).
Guix already provides a package definition which is a perfect example to start
with.  You can look up its declaration with  <code>guix edit hello</code> from the
command line.  Let’s see how it looks:
</p>

 <div class="org-src-container">
 <pre class="src src-scheme">(define-public hello
  (package
    (name "hello")
    (version "2.10")
    (source (origin
	      (method url-fetch)
	      (uri (string-append "mirror://gnu/hello/hello-" version
				  ".tar.gz"))
	      (sha256
	       (base32
		"0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
    (build-system gnu-build-system)
    (synopsis "Hello, GNU world: An example GNU package")
    (description
     "GNU Hello prints the message \"Hello, world!\" and then exits.  It
serves as an example of standard GNU coding practices.  As such, it supports
command-line arguments, multiple languages, and so on.")
    (home-page "https://www.gnu.org/software/hello/")
    (license gpl3+)))
</pre>
</div>

 <p>
As you can see, most of it is rather straightforward.  But let’s review the
fields together:
</p>

 <dl class="org-dl"> <dt>name</dt> <dd>The project name.  Using Scheme conventions, we prefer to keep it
lower case, without underscore and using dash-separated words.</dd>
 <dt>source</dt> <dd>This field contains a description of the source code origin.  The
 <code>origin</code> record contains these fields:
 <ol class="org-ol"> <li>The method, here  <code>url-fetch</code> to download via HTTP/FTP, but other methods
exist, such as  <code>git-fetch</code> for Git repositories.</li>
 <li>The URI, which is typically some  <code>https://</code> location for  <code>url-fetch</code>.  Here
the special  <code>mirror://gnu</code> refers to a set of well known locations, all of
which can be used by Guix to fetch the source, should some of them fail.</li>
 <li>The  <code>sha256</code> checksum of the requested file.  This is essential to ensure
the source is not corrupted.  Note that Guix works with base32 strings,
hence the call to the  <code>base32</code> function.</li>
</ol></dd>
 <dt>build-system</dt> <dd>This is where the power of abstraction provided by the Scheme
language really shines: in this case, the  <code>gnu-build-system</code>
abstracts away the famous  <code>./configure && make && make
                  install</code> shell invocations.  Other build systems include the
 <code>trivial-build-system</code> which does not do anything and requires
from the packager to program all the build steps, the
 <code>python-build-system</code>, the  <code>emacs-build-system</code>,  <a href="https://www.gnu.org/software/guix/manual/en/html_node/Build-Systems.html">and many
more</a>.</dd>
 <dt>synopsis</dt> <dd>It should be a concise summary of what the package
does.  For many packages a tagline from the
project’s home page can be used as the synopsis.</dd>
 <dt>description</dt> <dd>Same as for the synopsis, it’s fine to re-use the project
description from the homepage.  Note that Guix uses Texinfo
syntax.</dd>
 <dt>home-page</dt> <dd>Use HTTPS if available.</dd>
 <dt>license</dt> <dd>See  <code>guix/licenses.scm</code> in the project source for a full list.</dd>
</dl> <p>
Time to build our first package!  Nothing fancy here for now: we will stick to a
dummy “my-hello”, a copy of the above declaration.
</p>

 <p>
As with the ritualistic “Hello World” taught with most programming languages,
this will possibly be the most “manual” approach.  We will work out an ideal
setup later; for now we will go the simplest route.
</p>

 <p>
Save the following to a file  <code>my-hello.scm</code>.
</p>

 <div class="org-src-container">
 <pre class="src src-scheme">(use-modules (guix packages)
	     (guix download)
	     (guix build-system gnu)
	     (guix licenses))

(package
  (name "my-hello")
  (version "2.10")
  (source (origin
	    (method url-fetch)
	    (uri (string-append "mirror://gnu/hello/hello-" version
				".tar.gz"))
	    (sha256
	     (base32
	      "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
  (build-system gnu-build-system)
  (synopsis "Hello, Guix world: An example custom Guix package")
  (description
   "GNU Hello prints the message \"Hello, world!\" and then exits.  It
serves as an example of standard GNU coding practices.  As such, it supports
command-line arguments, multiple languages, and so on.")
  (home-page "https://www.gnu.org/software/hello/")
  (license gpl3+))
</pre>
</div>

 <p>
We will explain the extra code in a moment.
</p>

 <p>
Feel free to play with the different values of the various fields.  If you
change the source, you’ll need to update the checksum.  Indeed, Guix refuses to
build anything if the given checksum does not match the computed checksum of the
source code.  To obtain the correct checksum of the package declaration, we
need to download the source, compute the sha256 checksum and convert it to
base32.
</p>

 <p>
Thankfully, Guix can automate this task for us; all we need is to provide the
URI:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ guix download mirror://gnu/hello/hello-2.10.tar.gz

Starting download of /tmp/guix-file.JLYgL7
From https://ftpmirror.gnu.org/gnu/hello/hello-2.10.tar.gz...
following redirection to `https://mirror.ibcp.fr/pub/gnu/hello/hello-2.10.tar.gz'...
 …10.tar.gz  709KiB                                 2.5MiB/s 00:00 [##################] 100.0%
/gnu/store/hbdalsf5lpf01x4dcknwx6xbn6n5km6k-hello-2.10.tar.gz
0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i
</pre>
</div>

 <p>
In this specific case the output tells us which mirror was chosen.
</p>

 <p>
If the result of the above command is not the same as in the above snippet,
update your  <code>my-hello</code> declaration accordingly.
</p>

 <p>
Note that GNU package tarballs come with an OpenPGP signature, so you
should definitely check the signature of this tarball with `gpg` to
authenticate it before going further:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ guix download mirror://gnu/hello/hello-2.10.tar.gz.sig

Starting download of /tmp/guix-file.03tFfb
From https://ftpmirror.gnu.org/gnu/hello/hello-2.10.tar.gz.sig...
following redirection to `https://ftp.igh.cnrs.fr/pub/gnu/hello/hello-2.10.tar.gz.sig'...
 ….tar.gz.sig  819B                                 1.2MiB/s 00:00 [##################] 100.0%
/gnu/store/rzs8wba9ka7grrmgcpfyxvs58mly0sx6-hello-2.10.tar.gz.sig
0q0v86n3y38z17rl146gdakw9xc4mcscpk8dscs412j22glrv9jf
$ gpg --verify /gnu/store/rzs8wba9ka7grrmgcpfyxvs58mly0sx6-hello-2.10.tar.gz.sig /gnu/store/hbdalsf5lpf01x4dcknwx6xbn6n5km6k-hello-2.10.tar.gz
gpg: Signature made Sun 16 Nov 2014 01:08:37 PM CET
gpg:                using RSA key A9553245FDE9B739
gpg: Good signature from "Sami Kerola <kerolasa@iki.fi>" [unknown]
gpg:                 aka "Sami Kerola (http://www.iki.fi/kerolasa/) <kerolasa@iki.fi>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 8ED3 96E3 7E38 D471 A005  30D3 A955 3245 FDE9 B739
</pre>
</div>

 <p>
You can then happily run
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ guix package --install-from-file=my-hello.scm
</pre>
</div>

 <p>
You should now have  <code>my-hello</code> in your profile!
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ guix package --list-installed=my-hello
my-hello	2.10	out	/gnu/store/f1db2mfm8syb8qvc357c53slbvf1g9m9-my-hello-2.10
</pre>
</div>

 <p>
We’ve gone as far as we could without any knowledge of Scheme.  Now is the right
time to introduce the minimum we need from the language before we can proceed.
</p>
</div>
</div>

 <div id="outline-container-org5929eb0" class="outline-2">
 <h2 id="org5929eb0">A Scheme crash-course</h2>
 <div class="outline-text-2" id="text-org5929eb0">
 <p>
As we’ve seen above, basic packages don’t require much Scheme knowledge, if
at all.  But as you progress and your desire to write more and more complex
packages grows, it will become both necessary and empowering to hone your Lisper
skills.
</p>

 <p>
Since an extensive Lisp course is very much out of the scope of this tutorial,
we will only cover some basics here.
</p>

 <p>
Guix uses the Guile implementation of Scheme.  To start playing with the
language, install it with  <code>guix package --install guile</code> and start a  <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> by
running  <code>guile</code> from the command line.
</p>

 <p>
Alternatively you can also run  <code>guix environment --ad-hoc guile -- guile</code> if
you’d rather not have Guile installed in your user profile.
</p>

 <p>
In the following examples we use the  <code>></code> symbol to denote the REPL prompt, that
is, the line reserved for user input.  See  <a href="https://www.gnu.org/software/guile/manual/html_node/Using-Guile-Interactively.html">the Guile manual</a> for more details on
the REPL.
</p>

 <ul class="org-ul"> <li> <p>
Scheme syntax boils down to a tree of expressions (or  <i>s-expression</i> in Lisp
lingo).  An expression can be a literal such as numbers and strings, or a
compound which is a parenthesized list of compounds and literals.   <code>#t</code> and
 <code>#f</code> stand for the booleans “true” and “false”, respectively.
</p>

 <p>
Examples of valid expressions:
</p>
 <div class="org-src-container">
 <pre class="src src-scheme">> "Hello World!"
"Hello World!"
> 17
17
> (display (string-append "Hello " "Guix" "\n"))
"Hello Guix!"
</pre>
</div></li>

 <li>This last example is a function call embedded in another function call.  When
a parenthesized expression is evaluated, the first term is the function and
the rest are the arguments passed to the function.  Every function returns the
last evaluated expression as value.</li>

 <li> <p>
Anonymous functions are declared with the  <code>lambda</code> term:
</p>
 <div class="org-src-container">
 <pre class="src src-scheme">> (lambda (x) (* x x))
#<procedure 120e348 at <unknown port>:24:0 (x)>
</pre>
</div>
 <p>
The above lambda returns the square of its argument.  Since everything is an
expression, the  <code>lambda</code> expression returns an anonymous function, which can
in turn be applied to an argument:
</p>
 <div class="org-src-container">
 <pre class="src src-scheme">> ((lambda (x) (* x x)) 3)
9
</pre>
</div></li>

 <li> <p>
Anything can be assigned a global name with  <code>define</code>:
</p>
 <div class="org-src-container">
 <pre class="src src-scheme">> (define a 3)
> (define square (lambda (x) (* x x)))
> (square a)
9
</pre>
</div></li>

 <li> <p>
Procedures can be defined more concisely with the following syntax:
</p>
 <div class="org-src-container">
 <pre class="src src-scheme">(define (square x) (* x x))
</pre>
</div></li>

 <li> <p>
A list structure can be created with the  <code>list</code> procedure:
</p>
 <div class="org-src-container">
 <pre class="src src-scheme">> (list 2 a 5 7)
(2 3 5 7)
</pre>
</div></li>

 <li> <p>
The  <i>quote</i> disables evaluation of a parenthesized expression: the first term
is not called over the other terms.  Thus it effectively returns a list of
terms.
</p>
 <div class="org-src-container">
 <pre class="src src-scheme">> '(display (string-append "Hello " "Guix" "\n"))
(display (string-append "Hello " "Guix" "\n"))
> '(2 a 5 7)
(2 a 5 7)
</pre>
</div></li>

 <li> <p>
The  <i>quasiquote</i> disables evaluation of a parenthesized expression until a
comma re-enables it.  Thus it provides us with fine-grained control over what
is evaluated and what is not.
</p>
 <div class="org-src-container">
 <pre class="src src-scheme">> `(2 a 5 7 (2 ,a 5 ,(+ a 4)))
(2 a 5 7 (2 3 5 7))
</pre>
</div>
 <p>
Note that the above result is a list of mixed elements: numbers, symbols (here
 <code>a</code>) and the last element is a list itself.
</p></li>

 <li> <p>
Multiple variables can be named locally with  <code>let</code>:
</p>
 <div class="org-src-container">
 <pre class="src src-scheme">> (define x 10)
> (let ((x 2)
	(y 3))
    (list x y))
(2 3)
> x
10
> y
ERROR: In procedure module-lookup: Unbound variable: y
</pre>
</div>
 <p>
Use  <code>let*</code> to allow later variable declarations to refer to earlier
definitions.
</p>
 <div class="org-src-container">
 <pre class="src src-scheme">> (let* ((x 2)
	 (y (* x 3)))
    (list x y))
(2 6)
</pre>
</div></li>

 <li>The keyword syntax is  <code>#:</code>, it is used to create unique identifiers.  See also
the  <a href="https://www.gnu.org/software/guile/manual/html_node/Keywords.html">Keywords section in the Guile manual</a>.</li>

 <li>The percentage  <code>%</code> is typically used for read-only global variables in the
build stage.  Note that it is merely a convention, like  <code>_</code> in C.  Scheme Lisp
treats  <code>%</code> exactly the same as any other letter.</li>

 <li> <p>
Modules are created with  <code>define-module</code>.  For instance
</p>
 <div class="org-src-container">
 <pre class="src src-scheme">(define-module (guix build-system ruby)
  #:use-module (guix store)
  #:export (ruby-build
	    ruby-build-system))
</pre>
</div>
 <p>
defines the module  <code>ruby</code> which must be located in
 <code>guix/build-system/ruby.scm</code> somewhere in  <code>GUILE_LOAD_PATH</code>.  It depends on
the  <code>(guix store)</code> module and it exports two symbols,  <code>ruby-build</code> and
 <code>ruby-build-system</code>.
</p></li>
</ul> <p>
For a more detailed introduction, check out  <a href="http://www.troubleshooters.com/codecorn/scheme_guile/hello.htm">Scheme at a Glance</a>, by Steve Litt.
</p>

 <p>
One of the reference Scheme books is the seminal  <i>Structure and Interpretation
of Computer Programs</i>, by Harold Abelson and Gerald Jay Sussman, with Julie
Sussman.  You’ll find a free copy  <a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">online</a>, together with  <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">videos of the lectures
by the authors</a>.  The book is available in Texinfo format as the  <code>sicp</code> Guix
package.  Go ahead, run  <code>guix package --install sicp</code> and start reading with
 <code>info sicp</code> (or with the Emacs Info reader).  An unofficial ebook  <a href="https://sarabander.github.io/sicp/">is also
available</a>.
</p>

 <p>
You’ll find more books, tutorials and other resources at  <a href="https://schemers.org/">https://schemers.org/</a>.
</p>
</div>
</div>

 <div id="outline-container-org0fd28fa" class="outline-2">
 <h2 id="org0fd28fa">Setup</h2>
 <div class="outline-text-2" id="text-org0fd28fa">
 <p>
Now that we know some Scheme basics we can detail the different possible setups
for working on Guix packages.
</p>

 <p>
There are several ways to set up a Guix packaging environment.
</p>

 <p>
We recommend you work directly on the Guix source checkout since it makes it
easier for everyone to contribute to the project.
</p>

 <p>
But first, let’s look at other possibilities.
</p>
</div>

 <div id="outline-container-org8a2a94c" class="outline-3">
 <h3 id="org8a2a94c">Local file</h3>
 <div class="outline-text-3" id="text-org8a2a94c">
 <p>
This is what we previously did with  <code>my-hello</code>.  With the Scheme basics we’ve
covered, we are now able to explain the leading chunks.  As stated in  <code>guix
package --help</code>:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">-f, --install-from-file=FILE
		       install the package that the code within FILE
		       evaluates to
</pre>
</div>

 <p>
Thus the last expression  <i>must</i> return a package, which is the case in our
earlier example.
</p>

 <p>
The  <code>use-modules</code> expression tells which of the modules we need in the file.
Modules are a collection of values and procedures.  They are commonly called
“libraries” or “packages” in other programming languages.
</p>
</div>
</div>

 <div id="outline-container-org85b666d" class="outline-3">
 <h3 id="org85b666d"> <code>GUIX_PACKAGE_PATH</code></h3>
 <div class="outline-text-3" id="text-org85b666d">
 <p>
 <i>Note: Starting from Guix 0.16, the more flexible Guix “channels” are the
preferred way and supersede  <code>GUIX_PACKAGE_PATH</code>.  See below.</i>
</p>

 <p>
It can be tedious to specify the file from the command line instead of simply
calling  <code>guix package --install my-hello</code> as you would do with the official
packages.
</p>

 <p>
Guix makes it possible to streamline the process by adding as many “package
declaration paths” as you want.
</p>

 <p>
Create a directory, say  <code>~./guix-packages</code> and add it to the  <code>GUIX_PACKAGE_PATH</code>
environment variable:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ mkdir ~/guix-packages
$ export GUIX_PACKAGE_PATH=~/guix-packages
</pre>
</div>

 <p>
To add several directories, separate them with a colon ( <code>:</code>).
</p>

 <p>
Our previous  <code>my-hello</code> needs some adjustments though:
</p>

 <div class="org-src-container">
 <pre class="src src-scheme">(define-module (my-hello)
  #:use-module (guix licenses)
  #:use-module (guix packages)
  #:use-module (guix build-system gnu)
  #:use-module (guix download))

(define-public my-hello
  (package
    (name "my-hello")
    (version "2.10")
    (source (origin
	      (method url-fetch)
	      (uri (string-append "mirror://gnu/hello/hello-" version
				  ".tar.gz"))
	      (sha256
	       (base32
		"0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
    (build-system gnu-build-system)
    (synopsis "Hello, Guix world: An example custom Guix package")
    (description
     "GNU Hello prints the message \"Hello, world!\" and then exits.  It
serves as an example of standard GNU coding practices.  As such, it supports
command-line arguments, multiple languages, and so on.")
    (home-page "https://www.gnu.org/software/hello/")
    (license gpl3+)))
</pre>
</div>

 <p>
Note that we have assigned the package value to an exported variable name with
 <code>define-public</code>.  This is effectively assigning the package to the  <code>my-hello</code>
variable so that it can be referenced, among other as dependency of other
packages.
</p>

 <p>
If you use  <code>guix package --install-from-file=my-hello.scm</code> on the above file, it
will fail because the last expression,  <code>define-public</code>, does not return a
package.  If you want to use  <code>define-public</code> in this use-case nonetheless, make
sure the file ends with an evaluation of  <code>my-hello</code>:
</p>

 <div class="org-src-container">
 <pre class="src src-scheme">; ...
(define-public my-hello
  ; ...
  )

my-hello
</pre>
</div>

 <p>
This last example is not very typical.
</p>

 <p>
Now  <code>my-hello</code> should be part of the package collection like all other official
packages.  You can verify this with:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ guix package --show=my-hello
</pre>
</div>
</div>
</div>

 <div id="outline-container-orgf1ad5a1" class="outline-3">
 <h3 id="orgf1ad5a1">Guix channels</h3>
 <div class="outline-text-3" id="text-orgf1ad5a1">
 <p>
Guix 0.16 features channels, which is very similar to  <code>GUIX_PACKAGE_PATH</code> but
provides better integration and provenance tracking.  Channels are not
necessarily local, they can be maintained as a public Git repository for
instance.  Of course, several channels can be used at the same time.
</p>

 <p>
See the  <a href="http://guix.gnu.org/manual/en/html_node/Channels.html">“Channels” secion in the manual</a> for setup details.
</p>
</div>
</div>

 <div id="outline-container-org82c0b8f" class="outline-3">
 <h3 id="org82c0b8f">Direct checkout hacking</h3>
 <div class="outline-text-3" id="text-org82c0b8f">
 <p>
Working directly on the Guix project is recommended: it reduces the friction
when the time comes to submit your changes upstream to let the community benefit
from your hard work!
</p>

 <p>
Unlike most software distributions, the Guix repository holds in one place both
the tooling (including the package manager) and the package definitions.  This
choice was made so that it would give developers the flexibility to modify the
API without breakage by updating all packages at the same time.  This reduces
development inertia.
</p>

 <p>
Check out the official  <a href="https://git-scm.com/">Git</a> repository:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ git clone https://git.savannah.gnu.org/git/guix.git
</pre>
</div>

 <p>
In the rest of this article, we use  <code>$GUIX_CHECKOUT</code> to refer to the location of
the checkout.
</p>

 <p>
Follow the instruction from the  <a href="https://www.gnu.org/software/guix/manual/en/html_node/Contributing.html">“Contributing” chapter</a> in the manual to set up the
repository environment.
</p>

 <p>
Once ready, you should be able to use the package definitions from the
repository environment.
</p>

 <p>
Feel free to edit package definitions found in  <code>$GUIX_CHECKOUT/gnu/packages</code>.
</p>

 <p>
The  <code>$GUIX_CHECKOUT/pre-inst-env</code> script lets you use  <code>guix</code> over the package
collection of the repository.
</p>

 <ul class="org-ul"> <li> <p>
Search packages, such as Ruby:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ cd $GUIX_CHECKOUT
$ ./pre-inst-env guix package --list-available=ruby
    ruby    1.8.7-p374      out     gnu/packages/ruby.scm:119:2
    ruby    2.1.6   out     gnu/packages/ruby.scm:91:2
    ruby    2.2.2   out     gnu/packages/ruby.scm:39:2
</pre>
</div></li>

 <li> <p>
Build a package, here Ruby version 2.1:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ ./pre-inst-env guix build --keep-failed ruby@2.1
/gnu/store/c13v73jxmj2nir2xjqaz5259zywsa9zi-ruby-2.1.6
</pre>
</div></li>

 <li> <p>
Install it to your user profile:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ ./pre-inst-env guix package --install ruby@2.1
</pre>
</div></li>

 <li> <p>
Check for common mistakes:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ ./pre-inst-env guix lint ruby@2.1
</pre>
</div></li>
</ul> <p>
Guix strives at maintaining a high packaging standard; when contributing to the
Guix project, remember to
</p>

 <ul class="org-ul"> <li>follow the  <a href="https://www.gnu.org/software/guix/manual/en/html_node/Coding-Style.html">coding style</a>,</li>
 <li>and review the  <a href="https://www.gnu.org/software/guix/manual/en/html_node/Submitting-Patches.html">check list</a> from the manual.</li>
</ul> <p>
Once you are happy with the result, you are welcome to send your contribution to
make it part of Guix.  This process is also detailed in the  <a href="https://www.gnu.org/software/guix/manual/en/html_node/Contributing.html">manual</a>.
</p>

 <p>
It’s a community effort so the more join in, the better Guix becomes!
</p>
</div>
</div>
</div>

 <div id="outline-container-org1ee5d4e" class="outline-2">
 <h2 id="org1ee5d4e">Extended example</h2>
 <div class="outline-text-2" id="text-org1ee5d4e">
 <p>
The above “Hello World” example is as simple as it goes.  Packages can be more
complex than that and Guix can handle more advanced scenarios.  Let’s look at
another, more sophisticated package (slightly modified from the source):
</p>

 <div class="org-src-container">
 <pre class="src src-scheme">(define-module (gnu packages version-control)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module (guix utils)
  #:use-module (guix packages)
  #:use-module (guix git-download)
  #:use-module (guix build-system cmake)
  #:use-module (gnu packages ssh)
  #:use-module (gnu packages web)
  #:use-module (gnu packages pkg-config)
  #:use-module (gnu packages python)
  #:use-module (gnu packages compression)
  #:use-module (gnu packages tls))

(define-public my-libgit2
  (let ((commit "e98d0a37c93574d2c6107bf7f31140b548c6a7bf")
	(revision "1"))
    (package
      (name "my-libgit2")
      (version (git-version "0.26.6" revision commit))
      (source (origin
		(method git-fetch)
		(uri (git-reference
		      (url "https://github.com/libgit2/libgit2/")
		      (commit commit)))
		(file-name (git-file-name name version))
		(sha256
		 (base32
		  "17pjvprmdrx4h6bb1hhc98w9qi6ki7yl57f090n9kbhswxqfs7s3"))
		(patches (search-patches "libgit2-mtime-0.patch"))
		(modules '((guix build utils)))
		(snippet '(begin
			    ;; Remove bundled software.
			    (delete-file-recursively "deps")
			    #t))))
      (build-system cmake-build-system)
      (outputs '("out" "debug"))
      (arguments
       `(#:tests? #t                            ; Run the test suite (this is the default)
	 #:configure-flags '("-DUSE_SHA1DC=ON") ; SHA-1 collision detection
	 #:phases
	 (modify-phases %standard-phases
	   (add-after 'unpack 'fix-hardcoded-paths
	     (lambda _
	       (substitute* "tests/repo/init.c"
		 (("#!/bin/sh") (string-append "#!" (which "sh"))))
	       (substitute* "tests/clar/fs.h"
		 (("/bin/cp") (which "cp"))
		 (("/bin/rm") (which "rm")))
	       #t))
	   ;; Run checks more verbosely.
	   (replace 'check
	     (lambda _ (invoke "./libgit2_clar" "-v" "-Q")))
	   (add-after 'unpack 'make-files-writable-for-tests
	       (lambda _ (for-each make-file-writable (find-files "." ".*")))))))
      (inputs
       `(("libssh2" ,libssh2)
	 ("http-parser" ,http-parser)
	 ("python" ,python-wrapper)))
      (native-inputs
       `(("pkg-config" ,pkg-config)))
      (propagated-inputs
       ;; These two libraries are in 'Requires.private' in libgit2.pc.
       `(("openssl" ,openssl)
	 ("zlib" ,zlib)))
      (home-page "https://libgit2.github.com/")
      (synopsis "Library providing Git core methods")
      (description
       "Libgit2 is a portable, pure C implementation of the Git core methods
provided as a re-entrant linkable library with a solid API, allowing you to
write native speed custom Git applications in any language with bindings.")
      ;; GPLv2 with linking exception
      (license license:gpl2))))
</pre>
</div>

 <p>
(In those cases were you only want to tweak a few fields from a package
definition, you should rely on inheritance instead of copy-pasting everything.
See below.)
</p>

 <p>
Let’s discuss those fields in depth.
</p>
</div>

 <div id="outline-container-org785afc1" class="outline-3">
 <h3 id="org785afc1"> <code>git-fetch</code> method</h3>
 <div class="outline-text-3" id="text-org785afc1">
 <p>
Unlike the  <code>url-fetch</code> method,  <code>git-fetch</code> expects a  <code>git-reference</code> which takes
a Git repository and a commit.  The commit can be any Git reference such as
tags, so if the  <code>version</code> is tagged, then it can be used directly.  Sometimes
the tag is prefixed with a  <code>v</code>, in which case you’d use  <code>(commit (string-append
"v" version))</code>.
</p>

 <p>
To ensure that the source code from the Git repository is stored in a unique
directory with a readable name we use  <code>(file-name (git-file-name name
version))</code>.
</p>

 <p>
Note that there is also a  <code>git-version</code> procedure that can be used to derive the
version when packaging programs for a specific commit.
</p>
</div>
</div>

 <div id="outline-container-orgaf4d7b1" class="outline-3">
 <h3 id="orgaf4d7b1">Snippets</h3>
 <div class="outline-text-3" id="text-orgaf4d7b1">
 <p>
Snippets are quoted (i.e. non-evaluated) Scheme code that are a means of patching
the source.  They are a Guix-y alternative to the traditional  <code>.patch</code> files.
Because of the quote, the code in only evaluated when passed to the Guix daemon
for building.
</p>

 <p>
There can be as many snippet as needed.
</p>

 <p>
Snippets might need additional Guile modules which can be imported from the
 <code>modules</code> field.
</p>
</div>
</div>

 <div id="outline-container-org35087e3" class="outline-3">
 <h3 id="org35087e3">Inputs</h3>
 <div class="outline-text-3" id="text-org35087e3">
 <p>
First, a syntactic comment: See the quasi-quote / comma syntax?
</p>

 <div class="org-src-container">
 <pre class="src src-scheme">(native-inputs
 `(("pkg-config" ,pkg-config)))
</pre>
</div>

 <p>
is equivalent to
</p>

 <div class="org-src-container">
 <pre class="src src-scheme">(native-inputs
 (list (list "pkg-config" pkg-config)))
</pre>
</div>

 <p>
You’ll mostly see the former because it’s shorter.
</p>

 <p>
There are 3 different input types.  In short:
</p>

 <dl class="org-dl"> <dt>native-inputs</dt> <dd>Required for building but not runtime – installing a package
through a substitute won’t install these inputs.</dd>
 <dt>inputs</dt> <dd>Installed in the store but not in the profile, as well as being
present at build time.</dd>
 <dt>propagated-inputs</dt> <dd>Installed in the store and in the profile, as well as
being present at build time.</dd>
</dl> <p>
See  <a href="https://www.gnu.org/software/guix/manual/en/html_node/package-Reference.html">the package reference in the manual</a> for more details.
</p>

 <p>
The distinction between the various inputs is important: if a dependency can be
handled as an  <i>input</i> instead of a  <i>propagated input</i>, it should be done so, or
else it “pollutes” the user profile for no good reason.
</p>

 <p>
For instance, a user installing a graphical program that depends on a
command line tool might only be interested in the graphical part, so there is no
need to force the command line tool into the user profile.  The dependency is a
concern to the package, not to the user.   <i>Inputs</i> make it possible to handle
dependencies without bugging the user by adding undesired executable files (or
libraries) to their profile.
</p>

 <p>
Same goes for  <i>native-inputs</i>: once the program is installed, build-time
dependencies can be safely garbage-collected.
It also matters when a substitute is available, in which case only the  <i>inputs</i>
and  <i>propagated inputs</i> will be fetched: the  <i>native inputs</i> are not required to
install a package from a substitute.
</p>
</div>
</div>

 <div id="outline-container-org0d34a3c" class="outline-3">
 <h3 id="org0d34a3c">Outputs</h3>
 <div class="outline-text-3" id="text-org0d34a3c">
 <p>
Just like how a package can have multiple inputs, it can also produce multiple
outputs.
</p>

 <p>
Each output corresponds to a separate directory in the store.
</p>

 <p>
The user can choose which output to install; this is useful to save space or
to avoid polluting the user profile with unwanted executables or libraries.
</p>

 <p>
Output separation is optional.  When the  <code>outputs</code> field is left out, the
default and only output (the complete package) is referred to as  <code>"out"</code>.
</p>

 <p>
Typical separate output names include  <code>debug</code> and  <code>doc</code>.
</p>

 <p>
It’s advised to separate outputs only when you’ve shown it’s worth it: if the
output size is significant (compare with  <code>guix size</code>) or in case the package is
modular.
</p>
</div>
</div>

 <div id="outline-container-org7b0082f" class="outline-3">
 <h3 id="org7b0082f">Build system arguments</h3>
 <div class="outline-text-3" id="text-org7b0082f">
 <p>
The  <code>arguments</code> is a keyword-value list used to configure the build process.
</p>

 <p>
The simplest argument  <code>#:tests?</code> can be used to disable the test suite when
building the package.  This is mostly useful when the package does not feature
any test suite.  It’s strongly recommended to keep the test suite on if there is
one.
</p>

 <p>
Another  common argument is  <code>:make-flags</code>, which specifies a list of flags to
append when running make, as you would from the command line.  For instance, the
following flags
</p>

 <div class="org-src-container">
 <pre class="src src-scheme">#:make-flags (list (string-append "prefix=" (assoc-ref %outputs "out"))
		   "CC=gcc")
</pre>
</div>

 <p>
translate into
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ make CC=gcc prefix=/gnu/store/...-<out>
</pre>
</div>

 <p>
This sets the C compiler to  <code>gcc</code> and the  <code>prefix</code> variable (the installation
directory in Make parlance) to  <code>(assoc-ref %outputs "out")</code>, which is a build-stage
global variable pointing to the destination directory in the store (something like
 <code>/gnu/store/...-my-libgit2-20180408</code>).
</p>

 <p>
Similarly, it’s possible to set the “configure” flags.
</p>

 <div class="org-src-container">
 <pre class="src src-scheme">#:configure-flags '("-DUSE_SHA1DC=ON")
</pre>
</div>

 <p>
The  <code>%build-inputs</code> variable is also generated in scope.  It’s an association
table that maps the input names to their store directories.
</p>

 <p>
The  <code>phases</code> keyword lists the sequential steps of the build system.  Typically
phases include  <code>unpack</code>,  <code>configure</code>,  <code>build</code>,  <code>install</code> and  <code>check</code>.  To know
more about those phases, you need to work out the appropriate build system
definition in  <code>$GUIX_CHECKOUT/guix/build/gnu-build-system.scm</code>:
</p>

 <div class="org-src-container">
 <pre class="src src-scheme">(define %standard-phases
  ;; Standard build phases, as a list of symbol/procedure pairs.
  (let-syntax ((phases (syntax-rules ()
			 ((_ p ...) `((p . ,p) ...)))))
    (phases set-SOURCE-DATE-EPOCH set-paths install-locale unpack
	    bootstrap
	    patch-usr-bin-file
	    patch-source-shebangs configure patch-generated-file-shebangs
	    build check install
	    patch-shebangs strip
	    validate-runpath
	    validate-documentation-location
	    delete-info-dir-file
	    patch-dot-desktop-files
	    install-license-files
	    reset-gzip-timestamps
	    compress-documentation)))
</pre>
</div>

 <p>
Or from the REPL:
</p>

 <div class="org-src-container">
 <pre class="src src-scheme">> (add-to-load-path "/path/to/guix/checkout")
> ,module (guix build gnu-build-system)
> (map first %standard-phases)
(set-SOURCE-DATE-EPOCH set-paths install-locale unpack bootstrap patch-usr-bin-file patch-source-shebangs configure patch-generated-file-shebangs build check install patch-shebangs strip validate-runpath validate-documentation-location delete-info-dir-file patch-dot-desktop-files install-license-files reset-gzip-timestamps compress-documentation)
</pre>
</div>

 <p>
If you want to know more about what happens during those phases, consult the
associated procedures.
</p>

 <p>
For instance, as of this writing the definition of  <code>unpack</code> for the GNU build
system is
</p>

 <div class="org-src-container">
 <pre class="src src-scheme">(define* (unpack #:key source #:allow-other-keys)
  "Unpack SOURCE in the working directory, and change directory within the
source.  When SOURCE is a directory, copy it in a sub-directory of the current
working directory."
  (if (file-is-directory? source)
      (begin
	(mkdir "source")
	(chdir "source")

	;; Preserve timestamps (set to the Epoch) on the copied tree so that
	;; things work deterministically.
	(copy-recursively source "."
			  #:keep-mtime? #t))
      (begin
	(if (string-suffix? ".zip" source)
	    (invoke "unzip" source)
	    (invoke "tar" "xvf" source))
	(chdir (first-subdirectory "."))))
  #t)
</pre>
</div>

 <p>
Note the  <code>chdir</code> call: it changes the working directory to where the source was
unpacked.
Thus every phase following the  <code>unpack</code> will use the source as a working
directory, which is why we can directly work on the source files.
That is to say, unless a later phase changes the working directory to something
else.
</p>

 <p>
We modify the list of  <code>%standard-phases</code> of the build system with the
 <code>modify-phases</code> macro as per the list of specified modifications, which may have
the following forms:
</p>

 <ul class="org-ul"> <li> <code>(add-before PHASE NEW-PHASE PROCEDURE)</code>: Run  <code>PROCEDURE</code> named  <code>NEW-PHASE</code> before  <code>PHASE</code>.</li>
 <li> <code>(add-after PHASE NEW-PHASE PROCEDURE)</code>: Same, but afterwards.</li>
 <li> <code>(replace PHASE PROCEDURE)</code>.</li>
 <li> <code>(delete PHASE)</code>.</li>
</ul> <p>
The  <code>PROCEDURE</code> supports the keyword arguments  <code>inputs</code> and  <code>outputs</code>.  Each
input (whether  <i>native</i>,  <i>propagated</i> or not) and output directory is referenced
by their name in those variables.  Thus  <code>(assoc-ref outputs "out")</code> is the store
directory of the main output of the package.  A phase procedure may look like
this:
</p>

 <div class="org-src-container">
 <pre class="src src-scheme">(lambda* (#:key inputs outputs #:allow-other-keys)
  (let (((bash-directory (assoc-ref inputs "bash"))
	 (output-directory (assoc-ref outputs "out"))
	 (doc-directory (assoc-ref outputs "doc"))
  ; ...
  #t)
</pre>
</div>

 <p>
The procedure must return  <code>#t</code> on success.  It’s brittle to rely on the return
value of the last expression used to tweak the phase because there is no
guarantee it would be a  <code>#t</code>.  Hence the trailing  <code>#t</code> to ensure the right value
is returned on success.
</p>
</div>
</div>

 <div id="outline-container-orga25fdab" class="outline-3">
 <h3 id="orga25fdab">Code staging</h3>
 <div class="outline-text-3" id="text-orga25fdab">
 <p>
The astute reader may have noticed the quasi-quote and comma syntax in the
argument field.  Indeed, the build code in the package declaration should not be
evaluated on the client side, but only when passed to the Guix daemon.  This
mechanism of passing code around two running processes is called  <a href="https://arxiv.org/abs/1709.00833">code staging</a>.
</p>
</div>
</div>

 <div id="outline-container-org9cfde2c" class="outline-3">
 <h3 id="org9cfde2c">“Utils” functions</h3>
 <div class="outline-text-3" id="text-org9cfde2c">
 <p>
When customizing  <code>phases</code>, we often need to write code that mimics the
equivalent system invocations ( <code>make</code>,  <code>mkdir</code>,  <code>cp</code>, etc.) commonly used during
regular “Unix-style” installations.
</p>

 <p>
Some like  <code>chmod</code> are native to Guile.  See the  <a href="https://www.gnu.org/software/guile/manual/guile.html">Guile reference manual</a> for a
complete list.
</p>

 <p>
Guix provides additional helper functions which prove especially handy in the
context of package management.
</p>

 <p>
Some of those functions can be found in
 <code>$GUIX_CHECKOUT/guix/guix/build/utils.scm</code>.  Most of them mirror the behaviour
of the traditional Unix system commands:
</p>

 <dl class="org-dl"> <dt>which</dt> <dd>Like the  <code>which</code> system command.</dd>
 <dt>find-files</dt> <dd>Akin to the  <code>find</code> system command.</dd>
 <dt>mkdir-p</dt> <dd>Like  <code>mkdir -p</code>, which creates all parents as needed.</dd>
 <dt>install-file</dt> <dd>Similar to  <code>install</code> when installing a file to a (possibly
non-existing) directory.  Guile has  <code>copy-file</code> which works
like  <code>cp</code>.</dd>
 <dt>copy-recursively</dt> <dd>Like  <code>cp -r</code>.</dd>
 <dt>delete-file-recursively</dt> <dd>Like  <code>rm -rf</code>.</dd>
 <dt>invoke</dt> <dd>Run an executable.  This should be used instead of  <code>system*</code>.</dd>
 <dt>with-directory-excursion</dt> <dd>Run the body in a different working directory,
then restore the previous working directory.</dd>
 <dt>substitute*</dt> <dd>A “sed-like” function.</dd>
</dl></div>
</div>

 <div id="outline-container-org2ddfc94" class="outline-3">
 <h3 id="org2ddfc94">Module prefix</h3>
 <div class="outline-text-3" id="text-org2ddfc94">
 <p>
The license in our last example needs a prefix: this is because of how the
 <code>license</code> module was imported in the package, as  <code>#:use-module ((guix licenses)
#:prefix license:)</code>.  The  <a href="https://www.gnu.org/software/guile/manual/html_node/Using-Guile-Modules.html">Guile module import mechanism</a> gives the user full
control over namespacing: this is needed to avoid clashes between, say, the
 <code>zlib</code> variable from  <code>licenses.scm</code> (a  <i>license</i> value) and the  <code>zlib</code> variable
from  <code>compression.scm</code> (a  <i>package</i> value).
</p>
</div>
</div>
</div>

 <div id="outline-container-orgc94c0dc" class="outline-2">
 <h2 id="orgc94c0dc">Other build systems</h2>
 <div class="outline-text-2" id="text-orgc94c0dc">
 <p>
What we’ve seen so far covers the majority of packages using a build system
other than the  <code>trivial-build-system</code>.  The latter does not automate anything
and leaves you to build everything manually.  This can be more demanding and we
won’t cover it here for now, but thankfully it is rarely necessary to fall back
on this system.
</p>

 <p>
For the other build systems, such as ASDF, Emacs, Perl, Ruby and many more, the
process is very similar to the GNU build system except for a few specialized
arguments.
</p>

 <p>
Learn more about build systems in
</p>
 <ul class="org-ul"> <li> <a href="https://www.gnu.org/software/guix/manual/en/html_node/Build-Systems.html#Build-Systems">the manual, section 4.2 Build systems</a>,</li>
 <li>the source code in the  <code>$GUIX_CHECKOUT/guix/build</code> and
 <code>$GUIX_CHECKOUT/guix/build-system</code> directories.</li>
</ul></div>
</div>

 <div id="outline-container-orgf7b7af8" class="outline-2">
 <h2 id="orgf7b7af8">Programmable and automated package definition</h2>
 <div class="outline-text-2" id="text-orgf7b7af8">
 <p>
We can’t repeat it enough: having a full-fledged programming language at hand
empowers us in ways that reach far beyond traditional package management.
</p>

 <p>
Let’s illustrate this with some awesome features of Guix!
</p>
</div>

 <div id="outline-container-orge10d81e" class="outline-3">
 <h3 id="orge10d81e">Recursive importers</h3>
 <div class="outline-text-3" id="text-orge10d81e">
 <p>
You might find some build systems good enough that there is little to do at all
to write a package, to the point that it becomes repetitive and tedious after a
while.  A  <i>raison d’être</i> of computers is to replace human beings at those
boring tasks.  So let’s tell Guix to do this for us and create the package
definition of an R package from CRAN (the output is trimmed for conciseness):
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ guix import cran --recursive walrus

(define-public r-mc2d
    ; ...
    (license gpl2+)))

(define-public r-jmvcore
    ; ...
    (license gpl2+)))

(define-public r-wrs2
    ; ...
    (license gpl3)))

(define-public r-walrus
  (package
    (name "r-walrus")
    (version "1.0.3")
    (source
      (origin
	(method url-fetch)
	(uri (cran-uri "walrus" version))
	(sha256
	  (base32
	    "1nk2glcvy4hyksl5ipq2mz8jy4fss90hx6cq98m3w96kzjni6jjj"))))
    (build-system r-build-system)
    (propagated-inputs
      `(("r-ggplot2" ,r-ggplot2)
	("r-jmvcore" ,r-jmvcore)
	("r-r6" ,r-r6)
	("r-wrs2" ,r-wrs2)))
    (home-page "https://github.com/jamovi/walrus")
    (synopsis "Robust Statistical Methods")
    (description
      "This package provides a toolbox of common robust statistical tests, including robust descriptives, robust t-tests, and robust ANOVA.  It is also available as a module for 'jamovi' (see <https://www.jamovi.org> for more information).  Walrus is based on the WRS2 package by Patrick Mair, which is in turn based on the scripts and work of Rand Wilcox.  These analyses are described in depth in the book 'Introduction to Robust Estimation & Hypothesis Testing'.")
    (license gpl3)))
</pre>
</div>

 <p>
The recursive importer won’t import packages for which Guix already has package
definitions, except for the very first.
</p>

 <p>
Not all applications can be packaged this way, only those relying on a select
number of supported systems.  Read about the full list of importers in the  <a href="https://www.gnu.org/software/guix/manual/en/html_node/Invoking-guix-import.html">guix
import section</a> of the manual.
</p>
</div>
</div>

 <div id="outline-container-org0f1f535" class="outline-3">
 <h3 id="org0f1f535">Automatic update</h3>
 <div class="outline-text-3" id="text-org0f1f535">
 <p>
Guix can be smart enough to check for updates on systems it knows.  It can
report outdated package definitions with
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ guix refresh hello
</pre>
</div>

 <p>
In most cases, updating a package to a newer version requires little more than
changing the version number and the checksum.  Guix can do that automatically as
well:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ guix refresh hello --update
</pre>
</div>
</div>
</div>

 <div id="outline-container-orgf25f7fb" class="outline-3">
 <h3 id="orgf25f7fb">Inheritance</h3>
 <div class="outline-text-3" id="text-orgf25f7fb">
 <p>
If you’ve started browsing the existing package definitions, you might have
noticed that a significant number of them have a  <code>inherit</code> field:
</p>

 <div class="org-src-container">
 <pre class="src src-scheme">(define-public adwaita-icon-theme
  (package (inherit gnome-icon-theme)
    (name "adwaita-icon-theme")
    (version "3.26.1")
    (source (origin
	      (method url-fetch)
	      (uri (string-append "mirror://gnome/sources/" name "/"
				  (version-major+minor version) "/"
				  name "-" version ".tar.xz"))
	      (sha256
	       (base32
		"17fpahgh5dyckgz7rwqvzgnhx53cx9kr2xw0szprc6bnqy977fi8"))))
    (native-inputs
     `(("gtk-encode-symbolic-svg" ,gtk+ "bin")))))
</pre>
</div>

 <p>
All unspecified fields are inherited from the parent package.  This is very
convenient to create alternative packages, for instance with different source,
version or compilation options.
</p>
</div>
</div>
</div>

 <div id="outline-container-orgd2596e1" class="outline-2">
 <h2 id="orgd2596e1">Getting help</h2>
 <div class="outline-text-2" id="text-orgd2596e1">
 <p>
Sadly, some applications can be tough to package.  Sometimes they need a patch to
work with the non-standard filesystem hierarchy enforced by the store.
Sometimes the tests won’t run properly.  (They can be skipped but this is not
recommended.)  Other times the resulting package won’t be reproducible.
</p>

 <p>
Should you be stuck, unable to figure out how to fix any sort of packaging
issue, don’t hesitate to ask the community for help.
</p>

 <p>
See the  <a href="https://www.gnu.org/software/guix/contact/">Guix homepage</a> for information on the mailing lists, IRC, etc.
</p>
</div>
</div>

 <div id="outline-container-orgb052d26" class="outline-2">
 <h2 id="orgb052d26">Conclusion</h2>
 <div class="outline-text-2" id="text-orgb052d26">
 <p>
This tutorial was a showcase of the sophisticated package management that Guix
boasts.  At this point we have mostly restricted this introduction to the
 <code>gnu-build-system</code> which is a core abstraction layer on which more advanced
abstractions are based.
</p>

 <p>
Where do we go from here?  Next we ought to dissect the innards of the build
system by removing all abstractions, using the  <code>trivial-build-system</code>: this
should give us a thorough understanding of the process before investigating some
more advanced packaging techniques and edge cases.
</p>

 <p>
Other features worth exploring are the interactive editing and debugging
capabilities of Guix provided by the Guile REPL.
</p>

 <p>
Those fancy features are completely optional and can wait; now is a good time
to take a well-deserved break.  With what we’ve introduced here you should be
well armed to package lots of programs.  You can get started right away and
hopefully we will see your contributions soon!
</p>
</div>
</div>

 <div id="outline-container-org83d56df" class="outline-2">
 <h2 id="org83d56df">References</h2>
 <div class="outline-text-2" id="text-org83d56df">
 <ul class="org-ul"> <li>The  <a href="https://www.gnu.org/software/guix/manual/en/html_node/Defining-Packages.html">package reference in the manual</a></li>

 <li> <a href="https://gitlab.com/pjotrp/guix-notes/blob/master/HACKING.org">Pjotr’s hacking guide to GNU Guix</a></li>

 <li> <a href="https://www.gnu.org/software/guix/guix-ghm-andreas-20130823.pdf">“GNU Guix: Package without a scheme!”</a>, by Andreas Enge</li>
</ul></div>
</div>

 <div id="outline-container-orgb05e20a" class="outline-2">
 <h2 id="orgb05e20a">About GNU Guix</h2>
 <div class="outline-text-2" id="text-orgb05e20a">
 <p>
 <a href="https://www.gnu.org/software/guix">GNU Guix</a> is a transactional package manager for the GNU system.  The Guix System
Distribution or GuixSD is an advanced distribution of the GNU system that relies
on GNU Guix and  <a href="https://www.gnu.org/distros/free-system-distribution-guidelines.html">respects the user’s freedom</a>.
</p>

 <p>
In addition to standard package management features, Guix supports transactional
upgrades and roll-backs, unprivileged package management, per-user profiles, and
garbage collection.  Guix uses low-level mechanisms from the Nix package
manager, except that packages are defined as native  <a href="https://www.gnu.org/software/guile">Guile</a> modules, using
extensions to the  <a href="http://schemers.org">Scheme</a> language.  GuixSD offers a declarative approach to
operating system configuration management, and is highly customizable and
hackable.
</p>

 <p>
GuixSD can be used on an i686, x86_64, ARMV7 and AArch64 machines.  It is also
possible to use Guix on top of an already installed GNU/Linux system, including
on mips64el and aarch64.
</p>
</div>
</div>
</div>