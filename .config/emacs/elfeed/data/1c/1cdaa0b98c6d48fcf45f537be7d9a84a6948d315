<div id="content">
 <p>
 <i>Note: An updated version of this article is available in the  <a href="https://guix.gnu.org/cookbook/en/">cookbook</a>.</i>
</p>

 <p>
Guix provides a very useful feature that may be quite foreign to newcomers:
 <i>profiles</i>.  They are a way to group package installations together and all users
on the same system are free to use as many profiles as they want.
</p>

 <p>
Whether you’re a developer or not, you may find that multiple profiles bring you
great power and flexibility.  While they shift the paradigm somewhat compared to
 <i>traditional package managers</i>, they are very convenient to use once you’ve
understood how to set them up.
</p>

 <p>
If you are familiar with Python’s  <code>virtualenv</code>, you can think of a profile as a
kind of universal  <code>virtualenv</code> that can hold any kind of software whatsoever, not
just Python software.  Furthermore, profiles are self-sufficient: they capture
all the runtime dependencies which guarantees that all programs within a profile
will always work at any point in time.
</p>

 <p>
Multiple profiles have many benefits:
</p>

 <ul class="org-ul"> <li>Clean semantic separation of the various packages a user needs for different contexts.</li>

 <li>Multiple profiles can be made available into the environment either on login
or within a dedicated shell.</li>

 <li>Profiles can be loaded on demand.  For instance, the user can use multiple
shells, each of them running different profiles.</li>

 <li>Isolation: Programs from one profile will not use programs from the other, and
the user can even install different versions of the same programs to the two
profiles without conflict.</li>

 <li>Deduplication: Profiles share dependencies that happens to be the exact same.
This makes multiple profiles storage-efficient.</li>

 <li>Reproducible: when used with declarative manifests, a profile can be fully
specified by the Guix commit that was active when it was set up.  This means
that the exact same profile can be  <a href="https://guix.gnu.org/blog/2018/multi-dimensional-transactions-and-rollbacks-oh-my/">set up anywhere, anytime</a>, with just the
commit information.  See the section on  <a href="#org1668e1f">Reproducible profiles</a>.</li>

 <li>Easier upgrades and maintenance: Multiple profiles make it easy to keep
package listings at hand and make upgrades completely friction-less.</li>
</ul> <p>
Concretely, here follows some typical profiles:
</p>

 <ul class="org-ul"> <li>The dependencies of a project you are working on.</li>

 <li>Your favourite programming language libraries.</li>

 <li>Laptop-specific programs (like  <code>powertop</code>) that you don’t need on a desktop.</li>

 <li>TeXlive (this one can be really useful when you need to install just one
package for this one document you’ve just received over email).</li>

 <li>Games.</li>
</ul> <p>
Let’s dive in the set up!
</p>

 <div id="outline-container-org564cdf9" class="outline-2">
 <h2 id="org564cdf9">Basic setup with manifests</h2>
 <div class="outline-text-2" id="text-org564cdf9">
 <p>
A Guix profile can be set up  <i>via</i> a so-called  <i>manifest specification</i> that looks like
this:
</p>

 <div class="org-src-container">
 <pre class="src src-scheme">(specifications->manifest
  '("package-1"
    ;; Version 1.3 of package-2.
    "package-2@1.3"
    ;; The "lib" output of package-3.
    "package-3:lib"
    ; ...
    "package-N"))
</pre>
</div>

 <p>
See  <a href="https://guix.gnu.org/manual/en/html_node/Invoking-guix-package.html">(guix) Invoking guix package</a> for the syntax details.
</p>

 <p>
We can create a manifest specification per profile and install them this way:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">GUIX_EXTRA_PROFILES=$HOME/.guix-extra-profiles
mkdir -p "$GUIX_EXTRA_PROFILES"/my-project # if it does not exist yet
guix package --manifest=/path/to/guix-my-project-manifest.scm --profile="$GUIX_EXTRA_PROFILES"/my-project/my-project
</pre>
</div>

 <p>
Here we set an arbitrary variable  <code>GUIX_EXTRA_PROFILES</code> to point to the directory
where we will store our profiles in the rest of this article.
</p>

 <p>
Placing all your profiles in a single directory, with each profile getting its
own sub-directory, is somewhat cleaner.  This way, each sub-directory will
contain all the symlinks for precisely one profile.  Besides, “looping over
profiles” becomes obvious from any programming language (e.g. a shell script) by
simply looping over the sub-directories of  <code>$GUIX_EXTRA_PROFILES</code>.
</p>

 <p>
Note that it’s also possible to loop over the output of
</p>

 <div class="org-src-container">
 <pre class="src src-sh">guix package --list-profiles
</pre>
</div>

 <p>
although you’ll probably have to filter out  <code>~/.config/guix/current</code>.
</p>

 <p>
To enable all profiles on login, add this to your  <code>~/.bash_profile</code> (or similar):
</p>

 <div class="org-src-container">
 <pre class="src src-sh">for i in $GUIX_EXTRA_PROFILES/*; do
	profile=$i/$(basename "$i")
	if [ -f "$profile"/etc/profile ]; then
		GUIX_PROFILE="$profile"
		. "$GUIX_PROFILE"/etc/profile
	fi
	unset profile
done
</pre>
</div>

 <p>
Note to Guix System users: the above reflects how your default profile
 <code>~/.guix-profile</code> is activated from  <code>/etc/profile</code>, that latter being loaded by
 <code>~/.bashrc</code> by default.
</p>

 <p>
You can obviously choose to only enable a subset of them:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">for i in "$GUIX_EXTRA_PROFILES"/my-project-1 "$GUIX_EXTRA_PROFILES"/my-project-2; do
	profile=$i/$(basename "$i")
	if [ -f "$profile"/etc/profile ]; then
		GUIX_PROFILE="$profile"
		. "$GUIX_PROFILE"/etc/profile
	fi
	unset profile
done
</pre>
</div>

 <p>
When a profile is off, it’s straightforward to enable it for an individual shell
without “polluting” the rest of the user session:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">GUIX_PROFILE="path/to/my-project" ; . "$GUIX_PROFILE"/etc/profile
</pre>
</div>

 <p>
The key to enabling a profile is to  <i>source</i> its  <code>etc/profile</code> file.  This file
contains shell code that exports the right environment variables necessary to
activate the software contained in the profile.  It is built automatically by
Guix and meant to be sourced.
It contains the same variables you would get if you ran:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">guix package --search-paths=prefix --profile=$my_profile"
</pre>
</div>

 <p>
Once again, see  <a href="https://guix.gnu.org/manual/en/html_node/Invoking-guix-package.html">(guix) Invoking guix package</a> for the command line options.
</p>

 <p>
To upgrade a profile, simply install the manifest again:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">guix package -m /path/to/guix-my-project-manifest.scm -p "$GUIX_EXTRA_PROFILES"/my-project/my-project
</pre>
</div>

 <p>
To upgrade all profiles, it’s easy enough to loop over them.  For instance,
assuming your manifest specifications are stored in
 <code>~/.guix-manifests/guix-$profile-manifest.scm</code>, with  <code>$profile</code> being the name
of the profile (e.g. “project1”), you could do the following in Bourne shell:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">for profile in "$GUIX_EXTRA_PROFILES"/*; do
  guix package --profile="$profile" --manifest="$HOME/.guix-manifests/guix-$profile-manifest.scm"
done
</pre>
</div>

 <p>
Each profile has its own generations:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">guix package -p "$GUIX_EXTRA_PROFILES"/my-project/my-project --list-generations
</pre>
</div>

 <p>
You can roll-back to any generation of a given profile:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">guix package -p "$GUIX_EXTRA_PROFILES"/my-project/my-project --switch-generations=17
</pre>
</div>
</div>
</div>

 <div id="outline-container-org5bc5c11" class="outline-2">
 <h2 id="org5bc5c11">Required packages</h2>
 <div class="outline-text-2" id="text-org5bc5c11">
 <p>
Activating a profile essentially boils down to exporting a bunch of
environmental variables.  This is the role of the  <code>etc/profile</code> within the
profile.
</p>

 <p>
 <i>Note: Only the environmental variables of the packages that consume them will
be set.</i>
</p>

 <p>
For instance,  <code>MANPATH</code> won’t be set if there is no consumer application for man
pages within the profile.  So if you need to transparently access man pages once
the profile is loaded, you’ve got two options:
</p>

 <ul class="org-ul"> <li> <p>
Either export the variable manually, e.g.
</p>
 <div class="org-src-container">
 <pre class="src src-sh">export MANPATH=/path/to/profile${MANPATH:+:}$MANPATH
</pre>
</div></li>

 <li>Or include  <code>man-db</code> to the profile manifest.</li>
</ul> <p>
The same is true for  <code>INFOPATH</code> (you can install  <code>info-reader</code>),
 <code>PKG_CONFIG_PATH</code> (install  <code>pkg-config</code>), etc.
</p>
</div>
</div>

 <div id="outline-container-org5fb7297" class="outline-2">
 <h2 id="org5fb7297">Default profile</h2>
 <div class="outline-text-2" id="text-org5fb7297">
 <p>
What about the default profile that Guix keeps in  <code>~/.guix-profile</code>?
</p>

 <p>
You can assign it the role you want.  Typically you would install the manifest
of the packages you want to use all the time.
</p>

 <p>
Alternatively, you could keep it “manifest-less” for throw-away packages
that you would just use for a couple of days.
This way makes it convenient to run
</p>

 <div class="org-src-container">
 <pre class="src src-sh">guix install package-foo
guix upgrade package-bar
</pre>
</div>

 <p>
without having to specify the path to a profile.
</p>
</div>
</div>

 <div id="outline-container-org0727af2" class="outline-2">
 <h2 id="org0727af2">The benefits of manifests</h2>
 <div class="outline-text-2" id="text-org0727af2">
 <p>
Manifests are a convenient way to keep your package lists around and, say,
to synchronize them across multiple machines using a version control system.
</p>

 <p>
A common complaint about manifests is that they can be slow to install when they
contain large number of packages.  This is especially cumbersome when you just
want get an upgrade for one package within a big manifest.
</p>

 <p>
This is one more reason to use multiple profiles, which happen to be just
perfect to break down manifests into multiple sets of semantically connected
packages.  Using multiple, small profiles provides more flexibility and
usability.
</p>

 <p>
Manifests come with multiple benefits.  In particular, they ease maintenance:
</p>

 <ul class="org-ul"> <li>When a profile is set up from a manifest, the manifest itself is
self-sufficient to keep a “package listing” around and reinstall the profile
later or on a different system.  For ad-hoc profiles, we would need to
generate a manifest specification manually and maintain the package versions
for the packages that don’t use the default version.</li>

 <li> <code>guix package --upgrade</code> always tries to update the packages that have
propagated inputs, even if there is nothing to do.  Guix manifests remove this
problem.</li>

 <li>When partially upgrading a profile, conflicts may arise (due to diverging
dependencies between the updated and the non-updated packages) and they can be
annoying to resolve manually.  Manifests remove this problem altogether since
all packages are always upgraded at once.</li>

 <li>As mentioned above, manifests allow for reproducible profiles, while the
imperative  <code>guix install</code>,  <code>guix upgrade</code>, etc. do not, since they produce
different profiles every time even when they hold the same packages.  See
 <a href="https://issues.guix.gnu.org/issue/33285">the related discussion on the matter</a>.</li>

 <li>Manifest specifications are usable by other  <code>guix</code> commands.  For example, you
can run  <code>guix weather -m manifest.scm</code> to see how many substitutes are
available, which can help you decide whether you want to try upgrading today
or wait a while.  Another example: you can run  <code>guix pack -m manifest.scm</code> to
create a pack containing all the packages in the manifest (and their
transitive references).</li>

 <li>Finally, manifests have a Scheme representation, the  <code><manifest></code> record type.
They can be manipulated in Scheme and passed to the various Guix  <a href="https://en.wikipedia.org/wiki/Api">APIs</a>.</li>
</ul> <p>
It’s important to understand that while manifests can be used to declare
profiles, they are not strictly equivalent: profiles have the side effect that
they “pin” packages in the store, which prevents them from being
 <a href="https://guix.gnu.org/manual/en/html_node/Invoking-guix-gc.html">garbage-collected</a> and ensures that they will still be available at any point in
the future.
</p>

 <p>
Let’s take an example:
</p>

 <ol class="org-ol"> <li>We have an environment for hacking on a project for which there isn’t a Guix
package yet.  We build the environment using a manifest, and then run  <code>guix
   environment -m manifest.scm</code>.  So far so good.</li>

 <li>Many weeks pass and we have run a couple of  <code>guix pull</code> in the mean time.
Maybe a dependency from our manifest has been updated; or we may have run
 <code>guix gc</code> and some packages needed by our manifest have been
garbage-collected.</li>

 <li>Eventually, we set to work on that project again, so we run  <code>guix environment
   -m manifest.scm</code>.  But now we have to wait for Guix to build and install
stuff!</li>
</ol> <p>
Ideally, we could spare the rebuild time.  And indeed we can, all we need is to
install the manifest to a profile and use  <code>GUIX_PROFILE=/the/profile;
. "$GUIX_PROFILE"/etc/profile</code> as explained above: this guarantees that our
hacking environment will be available at all times.
</p>

 <p>
 <i>Security warning:</i> While keeping old profiles around can be convenient, keep in
mind that outdated packages may not have received the latest security fixes.
</p>
</div>
</div>

 <div id="outline-container-org1668e1f" class="outline-2">
 <h2 id="org1668e1f">Reproducible profiles</h2>
 <div class="outline-text-2" id="text-org1668e1f">
 <p>
To reproduce a profile bit-for-bit, we need two pieces of information:
</p>

 <ul class="org-ul"> <li>a manifest,</li>
 <li>a Guix channel specification.</li>
</ul> <p>
Indeed, manifests alone might not be enough: different Guix versions (or
different channels) can produce different outputs for a given manifest.
</p>

 <p>
You can output the Guix channel specification with  <code>guix describe
--format=channels</code>.
Save this to a file, say  <code>channel-specs.scm</code>.
</p>

 <p>
On another computer, you can use the channel specification file and the manifest
to reproduce the exact same profile:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">GUIX_EXTRA_PROFILES=$HOME/.guix-extra-profiles
GUIX_EXTRA=$HOME/.guix-extra

mkdir "$GUIX_EXTRA"/my-project
guix pull --channels=channel-specs.scm --profile "$GUIX_EXTRA/my-project/guix"

mkdir -p "$GUIX_EXTRA_PROFILES/my-project"
"$GUIX_EXTRA"/my-project/guix/bin/guix package --manifest=/path/to/guix-my-project-manifest.scm --profile="$GUIX_EXTRA_PROFILES"/my-project/my-project
</pre>
</div>

 <p>
It’s safe to delete the Guix channel profile you’ve just installed with the
channel specification, the project profile does not depend on it.
</p>
</div>
</div>

 <div id="outline-container-orga7a629b" class="outline-2">
 <h2 id="orga7a629b">Special thanks</h2>
 <div class="outline-text-2" id="text-orga7a629b">
 <p>
Chris Marusich and Simon Tournier for their thorough feedback.
</p>
</div>
</div>

 <div id="outline-container-orga12a3fe" class="outline-2">
 <h2 id="orga12a3fe">About GNU Guix</h2>
 <div class="outline-text-2" id="text-orga12a3fe">
 <p>
 <a href="https://www.gnu.org/software/guix">GNU Guix</a> is a transactional package manager and an advanced distribution of the
GNU system that  <a href="https://www.gnu.org/distros/free-system-distribution-guidelines.html">respects user freedom</a>. Guix can be used on top of any system
running the kernel Linux, or it can be used as a standalone operating system
distribution for i686, x86 <sub>64</sub>, ARMv7, and AArch64 machines.
</p>

 <p>
In addition to standard package management features, Guix supports transactional
upgrades and roll-backs, unprivileged package management, per-user profiles, and
garbage collection. When used as a standalone GNU/Linux distribution, Guix
offers a declarative, stateless approach to operating system configuration
management. Guix is highly customizable and hackable through  <a href="https://www.gnu.org/software/guile">Guile</a> programming
interfaces and extensions to the  <a href="http://schemers.org/">Scheme</a> language.
</p>
</div>
</div>
</div>