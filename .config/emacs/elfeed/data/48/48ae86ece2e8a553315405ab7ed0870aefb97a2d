<div id="content">
 <p>
A filesystem is the structure of some data storage.  They allow for storing file
hierarchically (folders), remembering metadata (timestamps, owners, etc.).
</p>

 <p>
The mechanics lying behind filesystems is often misunderstood.  As a consequence,
installing an operating systems is often perceived as a complex operation.  A few
enlightening explanations might help a great deal to alleviate this fear.
</p>

 <div id="outline-container-orgbf70d17" class="outline-2">
 <h2 id="orgbf70d17">Structure</h2>
 <div class="outline-text-2" id="text-orgbf70d17">
 <p>
The most important thing to grasp is that every computer storage device, from a
hardware point of view, is a continuous segment of memory.  The way data gets
organized by partitions, folders, metadata, etc. is defined logically by tools
and operating systems.
</p>
</div>

 <div id="outline-container-org5761ee2" class="outline-3">
 <h3 id="org5761ee2">Boot sectors and partition tables</h3>
 <div class="outline-text-3" id="text-org5761ee2">
 <p>
There are 2 types of boot sectors: the legacy  <i>Master Boot Record</i> (MBR) and the
newer  <i>GUID Partition Table</i> (GPT).  GPT has less limitations in regard to the
number and the size of the partitions.
</p>

 <p>
The boot sector and the partition table typically reside at the very beginning
of the disk.  They are not on any partition.  This would not make sense since the
partition table defines the partition layout.  On Linux, hard disk drives are
typically referenced by the path  <code>/dev/sdX</code>, where X is a letter, and their
partitions by the path  <code>/dev/sdXN</code>, where N a number.
</p>

 <p>
The OS and programs running on it identify partitions by the sector address (or
 <i>logical block address</i>, a.k.a. LBA) stored in the partition table.  The standard
starting sector for partitions is at byte 2048.  In the past, the first partition
used to be written at byte 63, which may cause performance issues since it does
not align with the physical sector size of the drive.  See the references for
more explanations.
</p>

 <p>
Tools for creating and manipulating the boot sector and the partition table
include  <code>dd</code>,  <code>syslinux</code>,  <code>grub</code>,  <code>fdisk</code>,  <code>gdisk</code> and more.  A tool like  <code>fdisk</code>
will manipulate the partition table found at the beginning of the designated
storage media.  As such, it usually only makes sense to call  <code>fdisk</code> over a hard
disk drive, such as  <code>fdisk /dev/sdX</code>, and not over a partition.
</p>

 <p>
The MBR has different partition types:  <i>primary</i>,  <i>extended</i> and  <i>logical</i>.  See
this  <a href="https://wiki.archlinux.org/index.php/Partitioning#Master_Boot_Record">Arch Wiki article</a> for more details.
</p>

 <p>
GPT has only one partition type.
</p>
</div>
</div>

 <div id="outline-container-org1fa7094" class="outline-3">
 <h3 id="org1fa7094">Partitions</h3>
 <div class="outline-text-3" id="text-org1fa7094">
 <p>
Partitions need to be initialized before they can be used by the OS, that is,
the  <i>header</i> must be created.  This header has different names depending on the
filesystem type (e.g.  <i>table of content</i>,  <i>superblock</i>).  The header will
usually occupy the first sectors of the partition.
</p>

 <p>
Tools such as  <code>mkfs</code> can be used to initialize partitions.
</p>

 <p>
As mentioned before, partitions are purely logical: it is possible to write data
across partitions with  <code>dd</code>.  Although that would probably destroy the logical
integrity of some partitions.
</p>

 <p>
If you remove the partition entry N, then partition N won’t exist in the eyes of
the OS.  But  <code>dd</code> can force reading data at any position on disk, and thus
recover data from lost partitions. If you re-add the partition entry with the
same LBA addresses, then the partition will be accessible just like before.
</p>
</div>
</div>

 <div id="outline-container-org9ca9b9e" class="outline-3">
 <h3 id="org9ca9b9e">Bootloaders</h3>
 <div class="outline-text-3" id="text-org9ca9b9e">
 <p>
The bootloader is a program that resides partly on a partition and partly on the
boot sector.
</p>

 <p>
When the computer starts, it will boot the designated media.  It will look for
an MBR or a GPT in the first sectors and run the executable code of the boot
loader.  This code can be configured to boot an OS located at a specific
partition.
</p>
</div>
</div>
</div>

 <div id="outline-container-orgbbeb7ba" class="outline-2">
 <h2 id="orgbbeb7ba">Disk usage and apparent size</h2>
 <div class="outline-text-2" id="text-orgbbeb7ba">
 <p>
Every file on the system has 2 “size” properties: the disk usage and the
apparent size.
</p>

 <p>
The apparent size is the number of bytes contained in a file.  It represents the
information held by the file, and as such it is the same across different file
systems.  It can be queried with  <code>ls -l</code> or  <code>du -b</code> (GNU) /  <code>du -A</code> (BSD).
</p>

 <p>
Disk usage is highly dependent on file systems.  It can be queried with  <code>ls -s</code>
or  <code>du</code>.  Disk usage accounts for several properties of the file:
</p>

 <ul class="org-ul"> <li>A file has attributes on the filesystem (e.g. timestamp, owner, etc.).  Thus it
usually requires some additional bytes.</li>

 <li>A file can be fragmented, have indirect blocks, have unused space in some
blocks, and the like.</li>

 <li>A file can be  <i>sparse</i>.  It means that it has big chunks of zeros.  Modern
filesystems make use of this property to save space, that is, they do not
write the zeros on the disk and only tell the filesystem that  <i>there are zeros
from byte M to byte N</i>.</li>
</ul> <p>
The disk usage is usually higher than the apparent size because of metadata and
fragmentation, but it can also be smaller if the file is sparse.
</p>

 <p>
Let’s experiment:
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ dd of=sparse-file bs=1k seek=5120 count=0
0+0 records in
0+0 records out
0 bytes (0 B) copied, 5.668e-05 s, 0.0 kB/s

$ du sparse-file
0

$ du -b sparse-file
5242880
</pre>
</div>

 <p>
Alternatively we can also use
</p>

 <div class="org-src-container">
 <pre class="src src-sh">$ truncate -s 5M sparse-file
</pre>
</div>

 <p>
The file is full of zeros and requires only 4 bytes on the filesystem, although
it contains 5242880 information bytes.
</p>
</div>
</div>

 <div id="outline-container-org8dc4929" class="outline-2">
 <h2 id="org8dc4929">Online resizing</h2>
 <div class="outline-text-2" id="text-org8dc4929">
 <p>
If the kernel and the filesystem support it, it is possible to resize online
partitions, e.g. the system partition.  Note that while extending a partition is
not problematic, shrinking a partition can cause data loss.
</p>

 <p>
Let’s see how this works on an ext4 filesystem.
</p>

 <p>
Warning: The whole process should not be interrupted.  Back up your partition
table and the data if possible.  Make sure the computer is powered by a battery
or a UPS.
</p>

 <ul class="org-ul"> <li>Delete the partition N from the partition table (e.g. with  <code>fdisk</code>), and
recreate it immediately with the same starting sector and the desired new
size.</li>

 <li>Run  <code>resize2fs /dev/sdXN</code> on partition N of disk X.</li>
</ul> <p>
And there is no need to restart the computer!
</p>

 <p>
See  <code>(8)resize2fs</code> for more options.
</p>
</div>
</div>

 <div id="outline-container-org8b82ee1" class="outline-2">
 <h2 id="org8b82ee1">References</h2>
 <div class="outline-text-2" id="text-org8b82ee1">
 <ul class="org-ul"> <li> <a href="https://wiki.archlinux.org/index.php/Partitioning">Arch Wiki/Partitioning</a></li>
 <li> <a href="https://en.wikipedia.org/wiki/GUID_Partition_Table">Wikipedia/GUID Partition Table</a></li>
 <li> <a href="https://en.wikipedia.org/wiki/Master_boot_record">Wikipedia/Master boot record</a></li>
 <li> <a href="http://en.wikipedia.org/wiki/Sparse_file">Wikipedia/Sparse file</a></li>
</ul></div>
</div>
</div>